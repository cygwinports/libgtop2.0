--- origsrc/libgtop-2.24.4/configure.in	2009-02-16 02:06:00.421875000 -0600
+++ src/libgtop-2.24.4/configure.in	2009-02-16 00:34:57.000000000 -0600
@@ -352,7 +352,7 @@ AC_SUBST(LIBGTOP_SERVER)
 
 if test x$libgtop_need_server = xyes ; then
    sysdeps_suid_lib="\$(top_builddir)/sysdeps/\$(sysdeps_dir)/libgtop_sysdeps_suid-2.0.la"
-   server_programs='libgtop_server2'
+   server_programs='libgtop_server2$(EXEEXT)'
 else
    sysdeps_suid_lib=
    server_programs=
@@ -381,6 +381,7 @@ sysdeps/solaris/Makefile
 sysdeps/aix/Makefile
 sysdeps/bsd/Makefile
 sysdeps/darwin/Makefile
+sysdeps/cygwin/Makefile
 src/Makefile
 src/daemon/Makefile
 lib/Makefile
--- origsrc/libgtop-2.24.4/libgtop-sysdeps.m4	2009-02-16 02:06:00.421875000 -0600
+++ src/libgtop-2.24.4/libgtop-sysdeps.m4	2009-02-16 00:34:57.000000000 -0600
@@ -103,6 +103,12 @@ AC_DEFUN([GNOME_LIBGTOP_SYSDEPS],[
 	  libgtop_have_sysinfo=yes
 	  libgtop_postinstall='chgrp kmem $(bindir)/libgtop_server2 && chmod g+s $(bindir)/libgtop_server2'
 	  ;;
+	cygwin*)
+	  libgtop_sysdeps_dir=cygwin
+	  libgtop_use_machine_h=no
+	  libgtop_need_server=no
+	  libgtop_have_sysinfo=yes
+	  ;;
 	*)
 	  if test x$hacker_mode = xyes ; then
 	    case "$host_os" in
--- origsrc/libgtop-2.24.4/sysdeps/Makefile.am	2009-02-16 02:06:00.421875000 -0600
+++ src/libgtop-2.24.4/sysdeps/Makefile.am	2009-02-16 00:34:57.000000000 -0600
@@ -2,4 +2,4 @@
 SUBDIRS			= common @sysdeps_dir@
 
 DIST_SUBDIRS		= bsd common linux osf1 \
-			  stub stub_suid sun4 freebsd solaris aix darwin
+			  stub stub_suid sun4 freebsd solaris aix darwin cygwin
--- origsrc/libgtop-2.24.4/sysdeps/cygwin/Makefile.am	1969-12-31 18:00:00.000000000 -0600
+++ src/libgtop-2.24.4/sysdeps/cygwin/Makefile.am	2009-02-16 00:34:57.000000000 -0600
@@ -0,0 +1,18 @@
+INCLUDES			= @INCLUDES@
+
+noinst_LTLIBRARIES		= libgtop_sysdeps-2.0.la
+
+libgtop_sysdeps_2_0_la_SOURCES	= open.c close.c cpu.c mem.c swap.c \
+				  uptime.c loadavg.c shm_limits.c msg_limits.c \
+				  sem_limits.c proclist.c procstate.c procuid.c \
+				  proctime.c procmem.c procsignal.c prockernel.c \
+				  procsegment.c procargs.c procmap.c siglist.c \
+				  sysinfo.c netload.c ppp.c glibtop_private.c \
+				  netlist.c procopenfiles.c procaffinity.c procwd.c
+
+libgtop_sysdeps_2_0_la_LIBADD	=  @GLIB_LIBS@
+
+libgtopinclude_HEADERS		= glibtop_server.h glibtop_machine.h
+libgtopincludedir		= $(includedir)/libgtop-2.0
+
+noinst_HEADERS			= glibtop_private.h
--- origsrc/libgtop-2.24.4/sysdeps/cygwin/close.c	1969-12-31 18:00:00.000000000 -0600
+++ src/libgtop-2.24.4/sysdeps/cygwin/close.c	2009-02-16 00:35:36.843750000 -0600
@@ -0,0 +1,29 @@
+/* Copyright (C) 1998-99 Martin Baulig
+   This file is part of LibGTop 1.0.
+
+   Contributed by Martin Baulig <martin@home-of-linux.org>, April 1998.
+
+   LibGTop is free software; you can redistribute it and/or modify it
+   under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License,
+   or (at your option) any later version.
+
+   LibGTop is distributed in the hope that it will be useful, but WITHOUT
+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+   for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with LibGTop; see the file COPYING. If not, write to the
+   Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.
+*/
+
+#include <config.h>
+#include <glibtop/close.h>
+
+/* Closes pipe to gtop server. */
+
+void
+glibtop_close_s (glibtop *server)
+{ }
--- origsrc/libgtop-2.24.4/sysdeps/cygwin/cpu.c	1969-12-31 18:00:00.000000000 -0600
+++ src/libgtop-2.24.4/sysdeps/cygwin/cpu.c	2009-02-16 00:40:56.937500000 -0600
@@ -0,0 +1,103 @@
+/* Copyright (C) 1998-99 Martin Baulig
+   This file is part of LibGTop 1.0.
+
+   Contributed by Martin Baulig <martin@home-of-linux.org>, April 1998.
+
+   LibGTop is free software; you can redistribute it and/or modify it
+   under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License,
+   or (at your option) any later version.
+
+   LibGTop is distributed in the hope that it will be useful, but WITHOUT
+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+   for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with LibGTop; see the file COPYING. If not, write to the
+   Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.
+*/
+
+#include <config.h>
+#include <glibtop/error.h>
+#include <glibtop/cpu.h>
+
+#include "glibtop_private.h"
+
+static const unsigned long _glibtop_sysdeps_cpu =
+(1L << GLIBTOP_CPU_TOTAL) + (1L << GLIBTOP_CPU_USER) +
+(1L << GLIBTOP_CPU_NICE) + (1L << GLIBTOP_CPU_SYS) +
+(1L << GLIBTOP_CPU_IDLE) + (1L << GLIBTOP_CPU_FREQUENCY);
+
+static const unsigned long _glibtop_sysdeps_cpu_smp =
+(1L << GLIBTOP_XCPU_TOTAL) + (1L << GLIBTOP_XCPU_USER) +
+(1L << GLIBTOP_XCPU_NICE) + (1L << GLIBTOP_XCPU_SYS) +
+(1L << GLIBTOP_XCPU_IDLE);
+
+/* Init function. */
+
+void
+_glibtop_init_cpu_s (glibtop *server)
+{
+	server->sysdeps.cpu = _glibtop_sysdeps_cpu;
+
+	if (server->ncpu)
+		server->sysdeps.cpu |= _glibtop_sysdeps_cpu_smp;
+}
+
+/* Provides information about cpu usage. */
+
+#define FILENAME	"/proc/stat"
+
+void
+glibtop_get_cpu_s (glibtop *server, glibtop_cpu *buf)
+{
+	char buffer [BUFSIZ], *p;
+	int i;
+
+	memset (buf, 0, sizeof (glibtop_cpu));
+
+	file_to_buffer(server, buffer, sizeof buffer, FILENAME);
+
+	/*
+	 * GLOBAL
+	 */
+
+	p = skip_token (buffer);	/* "cpu" */
+
+	buf->user = strtoull (p, &p, 0);
+	buf->nice = strtoull (p, &p, 0);
+	buf->sys  = strtoull (p, &p, 0);
+	buf->idle = strtoull (p, &p, 0);
+	buf->total = buf->user + buf->nice + buf->sys + buf->idle;
+
+	buf->frequency = 100;
+	buf->flags = _glibtop_sysdeps_cpu;
+
+	/*
+	 * PER CPU
+	 */
+
+	for (i = 0; i <= server->ncpu; i++) {
+
+		p = skip_line(p); /* move to ^ */
+
+		if (!check_cpu_line_warn(server, p, i))
+			break;
+
+		p = skip_token(p); /* "cpuN" */
+
+		buf->xcpu_user [i] = strtoull (p, &p, 0);
+		buf->xcpu_nice [i] = strtoull (p, &p, 0);
+		buf->xcpu_sys  [i] = strtoull (p, &p, 0);
+		buf->xcpu_idle [i] = strtoull (p, &p, 0);
+		buf->xcpu_total[i] = buf->xcpu_user [i] \
+			+ buf->xcpu_nice [i] \
+			+ buf->xcpu_sys  [i] \
+			+ buf->xcpu_idle [i];
+	}
+
+	if(server->ncpu) /* ok, that's a real SMP */
+		buf->flags |= _glibtop_sysdeps_cpu_smp;
+}
--- origsrc/libgtop-2.24.4/sysdeps/cygwin/glibtop_machine.h	1969-12-31 18:00:00.000000000 -0600
+++ src/libgtop-2.24.4/sysdeps/cygwin/glibtop_machine.h	2009-02-16 00:35:36.875000000 -0600
@@ -0,0 +1,44 @@
+/* Copyright (C) 1998-99 Martin Baulig
+   This file is part of LibGTop 1.0.
+
+   Contributed by Martin Baulig <martin@home-of-linux.org>, April 1998.
+
+   LibGTop is free software; you can redistribute it and/or modify it
+   under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License,
+   or (at your option) any later version.
+
+   LibGTop is distributed in the hope that it will be useful, but WITHOUT
+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+   for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with LibGTop; see the file COPYING. If not, write to the
+   Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.
+*/
+
+#ifndef __GLIBTOP_MACHINE_H__
+#define __GLIBTOP_MACHINE_H__
+
+#include <unistd.h>
+#include <fcntl.h>
+#include <ctype.h>
+
+G_BEGIN_DECLS
+
+typedef struct _glibtop_machine		glibtop_machine;
+
+struct _glibtop_machine
+{
+	pid_t	last_pid;
+	int	no_update;
+	int	fd_stat, fd_meminfo, fd_loadavg;
+	char	proc_stat [BUFSIZ], proc_statm [BUFSIZ];
+	char	proc_status [BUFSIZ];
+};
+
+G_END_DECLS
+
+#endif
--- origsrc/libgtop-2.24.4/sysdeps/cygwin/glibtop_private.c	1969-12-31 18:00:00.000000000 -0600
+++ src/libgtop-2.24.4/sysdeps/cygwin/glibtop_private.c	2009-02-16 00:45:59.671875000 -0600
@@ -0,0 +1,221 @@
+#include <config.h>
+#include <glibtop.h>
+#include <glibtop/error.h>
+
+#include "glibtop_private.h"
+
+#include <glib.h>
+
+#include <string.h>
+#include <stdlib.h>
+#include <stdarg.h>
+
+#include <fcntl.h>
+#include <unistd.h>
+
+
+unsigned long long
+get_scaled(const char *buffer, const char *key)
+{
+	const char    *ptr = buffer;
+	char	      *next;
+	unsigned long long value;
+
+	if (key) {
+		if (G_LIKELY((ptr = strstr(buffer, key))))
+			ptr += strlen(key);
+		else {
+			g_warning("Could not read key '%s' in buffer '%s'",
+				  key, buffer);
+			return 0;
+		}
+	}
+
+	value = strtoull(ptr, &next, 0);
+
+	for ( ; *next; ++next) {
+		if (*next == 'k') {
+			value *= 1024;
+			break;
+		} else if (*next == 'M') {
+			value *= 1024 * 1024;
+			break;
+		}
+	}
+
+	return value;
+}
+
+
+char *
+skip_token (const char *p)
+{
+	p = next_token(p);
+	while (*p && !isspace(*p)) p++;
+	p = next_token(p);
+	return (char *)p;
+}
+
+
+/*
+ * Read functions
+ */
+enum TRY_FILE_TO_BUFFER
+{
+	TRY_FILE_TO_BUFFER_OK = 0,
+	TRY_FILE_TO_BUFFER_OPEN = -1,
+	TRY_FILE_TO_BUFFER_READ = -2
+};
+
+/*
+ * Doesn't handle bufsiz == 0
+ */
+int try_file_to_buffer(char *buffer, size_t bufsiz, const char *format, ...)
+{
+	char path[4096];
+	int fd;
+	size_t len = 0;
+	ssize_t nread = 0;
+	va_list pa;
+
+	if (G_UNLIKELY(bufsiz <= sizeof(char*)))
+	  g_warning("Huhu, bufsiz of %lu looks bad", (gulong)bufsiz);
+
+	va_start(pa, format);
+
+	/* C99 also provides vsnprintf */
+	g_vsnprintf(path, sizeof path, format, pa);
+
+	va_end(pa);
+
+	bufsiz--; /* reserve 1 for trailing NUL */
+	buffer [0] = '\0';
+
+	if((fd = open (path, O_RDONLY)) < 0)
+		return TRY_FILE_TO_BUFFER_OPEN;
+
+	while (len < bufsiz) {
+		nread = read (fd, buffer + len, bufsiz - len);
+
+		if (G_UNLIKELY(nread < 0)) {
+			if (errno == EINTR)
+				continue;
+			else
+				break;
+		}
+
+		len += nread;
+
+		if (nread == 0)
+			break;
+	}
+
+	close (fd);
+
+	if (nread < 0)
+		return TRY_FILE_TO_BUFFER_READ;
+
+	buffer [len] = '\0';
+
+	return TRY_FILE_TO_BUFFER_OK;
+}
+
+
+void
+file_to_buffer(glibtop *server, char *buffer, size_t bufsiz, const char *filename)
+{
+	switch(try_file_to_buffer(buffer, bufsiz, filename))
+	{
+	case TRY_FILE_TO_BUFFER_OPEN:
+		glibtop_error_io_r (server, "open (%s)", filename);
+	case TRY_FILE_TO_BUFFER_READ:
+		glibtop_error_io_r (server, "read (%s)", filename);
+	}
+}
+
+
+
+
+static unsigned long
+read_boot_time(glibtop *server)
+{
+	char* line = NULL;
+	size_t size = 0;
+	FILE* stat;
+	unsigned long btime = 0;
+
+	if (!(stat = fopen("/proc/stat", "r"))) {
+		glibtop_error_io_r(server, "fopen(\"/proc/stat\")");
+		goto out;
+	}
+
+	while (getline(&line, &size, stat) != -1) {
+		if (!strncmp(line, "btime", 5)) {
+			btime = strtoul(skip_token(line), NULL, 10);
+			break;
+		}
+	}
+
+	free(line);
+	fclose(stat);
+out:
+	return btime;
+}
+
+
+
+unsigned long
+get_boot_time(glibtop *server)
+{
+	static unsigned long boot_time = 0UL;
+
+	if(G_UNLIKELY(!boot_time))
+	{
+		boot_time = read_boot_time(server);
+	}
+
+	return boot_time;
+}
+
+
+size_t
+get_page_size(void)
+{
+	static size_t pagesize = 0;
+
+	if(G_UNLIKELY(!pagesize))
+	{
+		pagesize = getpagesize();
+	}
+
+	return pagesize;
+}
+
+
+
+gboolean
+check_cpu_line(glibtop *server, const char *line, unsigned i)
+{
+	char start[10];
+
+	g_snprintf(start, sizeof start, "cpu%u", i);
+
+	return g_str_has_prefix(line, start);
+}
+
+
+
+gboolean safe_readlink(const char *path, char *buf, size_t bufsiz)
+{
+	ssize_t ret;
+
+	ret = readlink(path, buf, bufsiz - 1);
+
+	if (ret == -1) {
+		g_warning("Could not read link %s : %s", path, strerror(errno));
+		return FALSE;
+	}
+
+	buf[ret] = '\0';
+	return TRUE;
+}
--- origsrc/libgtop-2.24.4/sysdeps/cygwin/glibtop_private.h	1969-12-31 18:00:00.000000000 -0600
+++ src/libgtop-2.24.4/sysdeps/cygwin/glibtop_private.h	2009-02-16 00:46:56.734375000 -0600
@@ -0,0 +1,153 @@
+/* Copyright (C) 2004 Benoît Dejean
+   This file is part of LibGTop 2.0.
+
+   LibGTop is free software; you can redistribute it and/or modify it
+   under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License,
+   or (at your option) any later version.
+
+   LibGTop is distributed in the hope that it will be useful, but WITHOUT
+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+   for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with LibGTop; see the file COPYING. If not, write to the
+   Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.
+*/
+
+#ifndef __CYGWIN__GLIBTOP_PRIVATE_H__
+#define __CYGWIN__GLIBTOP_PRIVATE_H__
+
+#include <glibtop.h>
+#include <glibtop/error.h>
+
+#include <glib.h>
+
+#include <fcntl.h>
+#include <ctype.h>
+#include <string.h>
+
+G_BEGIN_DECLS
+
+
+
+static inline char*
+next_token(const char *p)
+{
+	while (isspace(*p)) p++;
+	return (char*) p;
+}
+
+char *
+skip_token (const char *p);
+
+static inline char *
+skip_multiple_token (const char *p, size_t count)
+{
+	while(count--)
+		p = skip_token (p);
+
+	return (char *)p;
+}
+
+
+static inline char *
+skip_line (const char *p)
+{
+	while (*p && *p != '\n') p++;
+	return (char *) (*p ? p+1 : p);
+}
+
+/*
+ * Smart strtoul which handles binary suffixes
+ * e.g: get_scaled("Size: 32 kB", "Size:") == 32768
+ * key can be NULL if there's not prefix to strip (or prefix size is known
+ */
+unsigned long long
+get_scaled(const char *buffer, const char *key);
+
+
+/* aborts on error */
+void
+file_to_buffer(glibtop *server, char *buffer, size_t bufsiz, const char *filename);
+
+/* return < 0 on error, otherwise 0 on success */
+int
+try_file_to_buffer(char *buffer, size_t bufsiz, const char *format, ...) G_GNUC_PRINTF(3, 4);
+
+
+/* some inline functions that wrap proc path
+ * as fast as macros :)
+ */
+
+static inline int
+proc_file_to_buffer (char *buffer, size_t bufsiz, const char *fmt, pid_t pid)
+{
+	return try_file_to_buffer(buffer, bufsiz, fmt, pid);
+}
+
+static inline int
+proc_stat_to_buffer (char *buffer, size_t bufsiz, pid_t pid)
+{
+	return proc_file_to_buffer(buffer, bufsiz, "/proc/%d/stat", pid);
+}
+
+static inline int
+proc_status_to_buffer (char *buffer, size_t bufsiz, pid_t pid)
+{
+	return proc_file_to_buffer(buffer, bufsiz, "/proc/%d/status", pid);
+}
+
+static inline int
+proc_statm_to_buffer (char *buffer, size_t bufsiz, pid_t pid)
+{
+	return proc_file_to_buffer(buffer, bufsiz, "/proc/%d/statm", pid);
+}
+
+
+static inline char *
+proc_stat_after_cmd (char *p)
+{
+	p = strrchr (p, ')');
+	if (G_LIKELY(p))
+		*p++ = '\0';
+	return p;
+}
+
+
+unsigned long
+get_boot_time(glibtop *server);
+
+
+size_t
+get_page_size(void);
+
+
+gboolean
+check_cpu_line(glibtop *server, const char *line, unsigned n);
+
+
+static inline gboolean
+check_cpu_line_warn(glibtop *server, const char *line, unsigned i)
+{
+	gboolean ret;
+
+	ret = check_cpu_line(server, line, i);
+
+	if (G_UNLIKELY(!ret))
+		glibtop_warn_io_r(server,
+				  "'%s' does not start with 'cpu%u'",
+				  line, i);
+
+	return ret;
+}
+
+
+gboolean safe_readlink(const char *path, char *buf, size_t bufsiz);
+
+
+G_END_DECLS
+
+#endif /* __CYGWIN__GLIBTOP_PRIVATE_H__ */
--- origsrc/libgtop-2.24.4/sysdeps/cygwin/glibtop_server.h	1969-12-31 18:00:00.000000000 -0600
+++ src/libgtop-2.24.4/sysdeps/cygwin/glibtop_server.h	2009-02-16 00:47:38.656250000 -0600
@@ -0,0 +1,50 @@
+/* Copyright (C) 1998-99 Martin Baulig
+   This file is part of LibGTop 1.0.
+
+   Contributed by Martin Baulig <martin@home-of-linux.org>, April 1998.
+
+   LibGTop is free software; you can redistribute it and/or modify it
+   under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License,
+   or (at your option) any later version.
+
+   LibGTop is distributed in the hope that it will be useful, but WITHOUT
+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+   for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with LibGTop; see the file COPYING. If not, write to the
+   Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.
+*/
+
+#ifndef __CYGWIN__GLIBTOP_SERVER_H__
+#define __CYGWIN__GLIBTOP_SERVER_H__
+
+#define GLIBTOP_SUID_CPU		0
+#define GLIBTOP_SUID_MEM		0
+#define GLIBTOP_SUID_SWAP		0
+#define GLIBTOP_SUID_UPTIME		0
+#define GLIBTOP_SUID_LOADAVG		0
+#define GLIBTOP_SUID_SHM_LIMITS		0
+#define GLIBTOP_SUID_MSG_LIMITS		0
+#define GLIBTOP_SUID_SEM_LIMITS		0
+#define GLIBTOP_SUID_PROCLIST		0
+#define GLIBTOP_SUID_PROC_STATE		0
+#define GLIBTOP_SUID_PROC_UID		0
+#define GLIBTOP_SUID_PROC_MEM		0
+#define GLIBTOP_SUID_PROC_TIME		0
+#define GLIBTOP_SUID_PROC_SIGNAL	0
+#define GLIBTOP_SUID_PROC_KERNEL	0
+#define GLIBTOP_SUID_PROC_SEGMENT	0
+#define GLIBTOP_SUID_PROC_ARGS		0
+#define GLIBTOP_SUID_PROC_MAP		0
+#define GLIBTOP_SUID_NETLOAD		0
+#define GLIBTOP_SUID_NETLIST		0
+#define GLIBTOP_SUID_PROC_WD		0
+#define GLIBTOP_SUID_PROC_AFFINITY	0
+#define GLIBTOP_SUID_PPP		0
+#define GLIBTOP_SUID_PROC_FILE		0
+
+#endif /* __CYGWIN__GLIBTOP_SERVER_H__ */
--- origsrc/libgtop-2.24.4/sysdeps/cygwin/loadavg.c	1969-12-31 18:00:00.000000000 -0600
+++ src/libgtop-2.24.4/sysdeps/cygwin/loadavg.c	2009-02-16 00:35:36.890625000 -0600
@@ -0,0 +1,81 @@
+/* Copyright (C) 1998-99 Martin Baulig
+   This file is part of LibGTop 1.0.
+
+   Contributed by Martin Baulig <martin@home-of-linux.org>, April 1998.
+
+   LibGTop is free software; you can redistribute it and/or modify it
+   under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License,
+   or (at your option) any later version.
+
+   LibGTop is distributed in the hope that it will be useful, but WITHOUT
+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+   for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with LibGTop; see the file COPYING. If not, write to the
+   Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.
+*/
+
+#include <config.h>
+#include <glibtop/error.h>
+#include <glibtop/loadavg.h>
+
+#include "glibtop_private.h"
+
+static const unsigned long _glibtop_sysdeps_loadavg =
+(1L << GLIBTOP_LOADAVG_LOADAVG);
+
+static const unsigned long _glibtop_sysdeps_loadavg_tasks =
+(1L << GLIBTOP_LOADAVG_NR_RUNNING) +
+(1L << GLIBTOP_LOADAVG_NR_TASKS) +
+(1L << GLIBTOP_LOADAVG_LAST_PID);
+
+/* Init function. */
+
+void
+_glibtop_init_loadavg_s (glibtop *server)
+{
+	server->sysdeps.loadavg = _glibtop_sysdeps_loadavg;
+}
+
+/* Provides load load averange. */
+
+#define FILENAME	"/proc/loadavg"
+
+void
+glibtop_get_loadavg_s (glibtop *server, glibtop_loadavg *buf)
+{
+	char buffer [BUFSIZ], *p, *old;
+
+	memset (buf, 0, sizeof (glibtop_loadavg));
+
+	file_to_buffer(server, buffer, sizeof buffer, FILENAME);
+
+	buf->loadavg [0] = g_ascii_strtod (buffer, &p);
+	buf->loadavg [1] = g_ascii_strtod (p, &p);
+	buf->loadavg [2] = g_ascii_strtod (p, &p);
+
+	buf->flags = _glibtop_sysdeps_loadavg;
+
+	p = next_token(p);
+
+	/* Older Linux versions don't have the nr_running/nr_tasks fields. */
+
+	old = p;
+	while (*p) {
+		if (*p == '/')
+			break;
+		if (!isdigit (*p))
+			return;
+		p++;
+	}
+
+	buf->nr_running  = strtoull (old, &p, 0); p++;
+	buf->nr_tasks    = strtoull (p, &p, 0);
+	buf->last_pid    = strtoull (p, &p, 0);
+
+	buf->flags |= _glibtop_sysdeps_loadavg_tasks;
+}
--- origsrc/libgtop-2.24.4/sysdeps/cygwin/mem.c	1969-12-31 18:00:00.000000000 -0600
+++ src/libgtop-2.24.4/sysdeps/cygwin/mem.c	2009-02-16 01:46:30.671875000 -0600
@@ -0,0 +1,61 @@
+/* Copyright (C) 1998-99 Martin Baulig
+   This file is part of LibGTop 1.0.
+
+   Contributed by Martin Baulig <martin@home-of-linux.org>, April 1998.
+
+   LibGTop is free software; you can redistribute it and/or modify it
+   under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License,
+   or (at your option) any later version.
+
+   LibGTop is distributed in the hope that it will be useful, but WITHOUT
+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+   for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with LibGTop; see the file COPYING. If not, write to the
+   Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.
+*/
+
+#include <config.h>
+#include <glibtop/error.h>
+#include <glibtop/mem.h>
+
+#include "glibtop_private.h"
+
+static const unsigned long _glibtop_sysdeps_mem =
+(1L << GLIBTOP_MEM_TOTAL) + (1L << GLIBTOP_MEM_USED) +
+(1L << GLIBTOP_MEM_FREE) + (1L << GLIBTOP_MEM_SHARED) +
+(1L << GLIBTOP_MEM_USER);
+
+/* Init function. */
+
+void
+_glibtop_init_mem_s (glibtop *server)
+{
+	server->sysdeps.mem = _glibtop_sysdeps_mem;
+}
+
+/* Provides information about memory usage. */
+
+#define FILENAME	"/proc/meminfo"
+
+void
+glibtop_get_mem_s (glibtop *server, glibtop_mem *buf)
+{
+	char buffer [BUFSIZ];
+
+	memset(buf, 0, sizeof *buf);
+
+	file_to_buffer(server, buffer, sizeof buffer, FILENAME);
+
+	buf->total  = get_scaled(buffer, "MemTotal:");
+	buf->free   = get_scaled(buffer, "MemFree:");
+	buf->used   = buf->total - buf->free;
+	buf->shared = 0;
+
+	buf->user = buf->total - buf->free;
+	buf->flags = _glibtop_sysdeps_mem;
+}
--- origsrc/libgtop-2.24.4/sysdeps/cygwin/mountlist.c	1969-12-31 18:00:00.000000000 -0600
+++ src/libgtop-2.24.4/sysdeps/cygwin/mountlist.c	2009-02-16 00:35:36.890625000 -0600
@@ -0,0 +1,166 @@
+/* mountlist.c -- return a list of mounted filesystems
+   Copyright (C) 1991, 1992 Free Software Foundation, Inc.
+
+   This file is a fork of sysdeps/common/mountlist.c.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software Foundation,
+   Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
+
+
+/*
+Local Variables:
+mode: C
+c-file-style: "gnu"
+End:
+*/
+
+#include <config.h>
+
+#include <stdio.h>
+#include <mntent.h>
+
+#include <glibtop.h>
+#include <glibtop/mountlist.h>
+#include <glibtop/error.h>
+
+
+/* IgnoreList */
+
+
+typedef struct
+{
+  GHashTable *table;
+} IgnoreList;
+
+
+static IgnoreList*
+ignore_list_new(void)
+{
+  IgnoreList* ig;
+  ig = g_new(IgnoreList, 1);
+  ig->table = g_hash_table_new_full(g_str_hash, g_str_equal, g_free, NULL);
+  return ig;
+}
+
+
+static void
+ignore_list_delete(IgnoreList* ig)
+{
+  if (ig) {
+    g_hash_table_destroy(ig->table);
+    g_free(ig);
+  }
+}
+
+
+static void
+ignore_list_add(IgnoreList* ig, const char* fs)
+{
+  g_hash_table_insert(ig->table, g_strdup(fs), GINT_TO_POINTER(1));
+}
+
+
+static gboolean
+ignore_list_has(IgnoreList* ig, const char* fs)
+{
+  gpointer data;
+  data = g_hash_table_lookup(ig->table, fs);
+  return data != NULL;
+}
+
+
+/* ~IgnoreList */
+
+
+static gboolean
+ignore_fs(const char *fstype, IgnoreList** ig)
+{
+  if (!*ig) {
+    FILE* fs;
+    char line[128];
+
+    *ig = ignore_list_new();
+
+    if ((fs = fopen("/proc/filesystems", "r")) != NULL) {
+      while (fgets(line, sizeof line, fs)) {
+	if (!strncmp(line, "nodev", 5)) {
+	  char *type;
+	  type = g_strstrip(line + 5);
+	  ignore_list_add(*ig, type);
+	}
+      }
+      fclose(fs);
+    }
+  }
+
+  return ignore_list_has(*ig, fstype);
+}
+
+
+glibtop_mountentry *
+glibtop_get_mountlist_s(glibtop *server, glibtop_mountlist *buf, int all_fs)
+{
+  const struct mntent *mnt;
+  FILE *fp;
+  GArray* entries;
+  IgnoreList* ig = NULL;
+
+  glibtop_init_r(&server, 0, 0);
+  memset(buf, 0, sizeof(glibtop_mountlist));
+
+  /* wild guess, preallocate 8 entries
+     on a desktop, almost everyone has / and a tmpfs for udev
+     if all_fs, there are also proc, sys, fuse, binfmt, etc */
+  entries = g_array_sized_new(FALSE, FALSE, sizeof(glibtop_mountentry), 8);
+
+  if (!(fp = setmntent(MOUNTED, "r"))) {
+      glibtop_warn_io_r(server, "Could not open %s", MOUNTED);
+      goto out;
+    }
+
+  while ((mnt = getmntent(fp)))
+    {
+      glibtop_mountentry *me;
+      const char *devopt;
+      gsize len;
+
+      if (!all_fs && ignore_fs(mnt->mnt_type, &ig))
+	continue;
+
+      len = entries->len;
+      g_array_set_size(entries, len + 1);
+      me = &g_array_index(entries, glibtop_mountentry, len);
+
+      g_strlcpy(me->devname, mnt->mnt_fsname, sizeof me->devname);
+      g_strlcpy(me->mountdir, mnt->mnt_dir, sizeof me->mountdir);
+      g_strlcpy(me->type, mnt->mnt_type, sizeof me->type);
+      devopt = strstr(mnt->mnt_opts, "dev=");
+      me->dev = (devopt ? strtoull(devopt + sizeof "dev=", NULL, 0) : (dev_t)-1);
+    }
+
+    endmntent(fp);
+
+
+  out:
+    ignore_list_delete(ig);
+
+    buf->size = sizeof(glibtop_mountentry);
+    buf->number = entries->len;
+    buf->total = buf->number * buf->size;
+    buf->flags = (1 << GLIBTOP_MOUNTLIST_SIZE)
+    | (1 << GLIBTOP_MOUNTLIST_NUMBER)
+    | (1 << GLIBTOP_MOUNTLIST_TOTAL);
+
+  return (glibtop_mountentry*) g_array_free(entries, FALSE);
+}
--- origsrc/libgtop-2.24.4/sysdeps/cygwin/msg_limits.c	1969-12-31 18:00:00.000000000 -0600
+++ src/libgtop-2.24.4/sysdeps/cygwin/msg_limits.c	2009-02-16 01:34:38.359375000 -0600
@@ -0,0 +1,60 @@
+/* Copyright (C) 1998-99 Martin Baulig
+   This file is part of LibGTop 1.0.
+
+   Contributed by Martin Baulig <martin@home-of-linux.org>, April 1998.
+
+   LibGTop is free software; you can redistribute it and/or modify it
+   under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License,
+   or (at your option) any later version.
+
+   LibGTop is distributed in the hope that it will be useful, but WITHOUT
+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+   for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with LibGTop; see the file COPYING. If not, write to the
+   Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.
+*/
+
+#include <config.h>
+#include <glibtop/msg_limits.h>
+
+#define _KERNEL
+#include <sys/ipc.h>
+#include <sys/msg.h>
+
+static const unsigned long _glibtop_sysdeps_msg_limits =
+(1L << GLIBTOP_IPC_MSGPOOL) + (1L << GLIBTOP_IPC_MSGMAP) +
+(1L << GLIBTOP_IPC_MSGMAX) + (1L << GLIBTOP_IPC_MSGMNB) +
+(1L << GLIBTOP_IPC_MSGMNI) + (1L << GLIBTOP_IPC_MSGSSZ) +
+(1L << GLIBTOP_IPC_MSGTQL);
+
+/* Init function. */
+
+void
+_glibtop_init_msg_limits_s (glibtop *server)
+{
+	server->sysdeps.msg_limits = _glibtop_sysdeps_msg_limits;
+}
+
+/* Provides information about sysv ipc limits. */
+
+void
+glibtop_get_msg_limits_s (glibtop *server, glibtop_msg_limits *buf)
+{
+	struct msginfo msginfo;
+
+	memset (buf, 0, sizeof (glibtop_msg_limits));
+
+	msgctl (0, IPC_INFO, (void*) &msginfo);
+
+	buf->msgmax = msginfo.msgmax;
+	buf->msgmnb = msginfo.msgmnb;
+	buf->msgmni = msginfo.msgmni;
+	buf->msgssz = msginfo.msgssz;
+	buf->msgtql = msginfo.msgtql;
+	buf->flags = _glibtop_sysdeps_msg_limits;
+}
--- origsrc/libgtop-2.24.4/sysdeps/cygwin/netlist.c	1969-12-31 18:00:00.000000000 -0600
+++ src/libgtop-2.24.4/sysdeps/cygwin/netlist.c	2009-02-16 01:49:33.921875000 -0600
@@ -0,0 +1,46 @@
+/* Copyright (C) 1998-99 Martin Baulig
+   This file is part of LibGTop 1.0.
+
+   Contributed by Martin Baulig <martin@home-of-linux.org>, April 1998.
+
+   LibGTop is free software; you can redistribute it and/or modify it
+   under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License,
+   or (at your option) any later version.
+
+   LibGTop is distributed in the hope that it will be useful, but WITHOUT
+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+   for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with LibGTop; see the file COPYING. If not, write to the
+   Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.
+*/
+
+#include <config.h>
+#include <glibtop/netlist.h>
+#include <glibtop/error.h>
+
+#include <stdio.h>
+
+
+static const unsigned long _glibtop_sysdeps_netlist = 0;
+
+/* Init function. */
+
+void
+_glibtop_init_netlist_s (glibtop *server)
+{
+	server->sysdeps.netlist = _glibtop_sysdeps_netlist;
+}
+
+
+char**
+glibtop_get_netlist_s (glibtop *server, glibtop_netlist *buf)
+{
+	memset (buf, 0, sizeof (glibtop_netlist));
+	return NULL;
+}
+
--- origsrc/libgtop-2.24.4/sysdeps/cygwin/netload.c	1969-12-31 18:00:00.000000000 -0600
+++ src/libgtop-2.24.4/sysdeps/cygwin/netload.c	2009-02-16 00:52:14.562500000 -0600
@@ -0,0 +1,44 @@
+/* Copyright (C) 1998-99 Martin Baulig
+   This file is part of LibGTop 1.0.
+
+   Contributed by Martin Baulig <martin@home-of-linux.org>, October 1998.
+
+   LibGTop is free software; you can redistribute it and/or modify it
+   under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License,
+   or (at your option) any later version.
+
+   LibGTop is distributed in the hope that it will be useful, but WITHOUT
+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+   for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with LibGTop; see the file COPYING. If not, write to the
+   Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.
+*/
+
+#include <config.h>
+#include <glibtop.h>
+#include <glibtop/error.h>
+#include <glibtop/netload.h>
+
+static const unsigned long _glibtop_sysdeps_netload = 0;
+
+/* Init function. */
+
+void
+_glibtop_init_netload_s (glibtop *server)
+{
+	server->sysdeps.netload = _glibtop_sysdeps_netload;
+}
+
+/* Provides network statistics. */
+
+void
+glibtop_get_netload_s (glibtop *server, glibtop_netload *buf,
+		       const char *interface)
+{
+	memset (buf, 0, sizeof (glibtop_netload));
+}
--- origsrc/libgtop-2.24.4/sysdeps/cygwin/open.c	1969-12-31 18:00:00.000000000 -0600
+++ src/libgtop-2.24.4/sysdeps/cygwin/open.c	2009-02-16 00:56:44.093750000 -0600
@@ -0,0 +1,68 @@
+/* Copyright (C) 1998-99 Martin Baulig
+   This file is part of LibGTop 1.0.
+
+   Contributed by Martin Baulig <martin@home-of-linux.org>, April 1998.
+
+   LibGTop is free software; you can redistribute it and/or modify it
+   under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License,
+   or (at your option) any later version.
+
+   LibGTop is distributed in the hope that it will be useful, but WITHOUT
+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+   for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with LibGTop; see the file COPYING. If not, write to the
+   Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.
+*/
+
+#include <config.h>
+#include <glibtop.h>
+#include <glibtop/cpu.h>
+#include <glibtop/open.h>
+#include <glibtop/error.h>
+
+#include "glibtop_private.h"
+
+/* ======================================================= */
+
+/* Opens pipe to gtop server. Returns 0 on success and -1 on error. */
+
+#define FILENAME	"/proc/stat"
+
+void
+glibtop_open_s (glibtop *server, const char *program_name,
+		const unsigned long features,
+		const unsigned flags)
+{
+	char buffer [BUFSIZ], *p = buffer;
+
+	server->name = program_name;
+
+	file_to_buffer(server, buffer, sizeof buffer, FILENAME);
+
+	p = skip_line(p); /* cpu */
+
+	for (server->real_ncpu = 0; /* nop */; server->real_ncpu++) {
+
+		if (!check_cpu_line(server, p, server->real_ncpu)) {
+			server->real_ncpu--;
+			break;
+		}
+
+		p = skip_line(p);
+	}
+
+	server->ncpu = MIN(GLIBTOP_NCPU - 1, server->real_ncpu);
+
+	if (server->real_ncpu != server->ncpu) {
+		glibtop_warn_r(server,
+			       "This machine has %d CPUs, "
+			       "%d are being monitored.",
+			       server->real_ncpu + 1,
+			       server->ncpu + 1);
+	}
+}
--- origsrc/libgtop-2.24.4/sysdeps/cygwin/ppp.c	1969-12-31 18:00:00.000000000 -0600
+++ src/libgtop-2.24.4/sysdeps/cygwin/ppp.c	2009-02-16 00:57:02.281250000 -0600
@@ -0,0 +1,43 @@
+/* Copyright (C) 1998-99 Martin Baulig
+   This file is part of LibGTop 1.0.
+
+   Contributed by Martin Baulig <martin@home-of-linux.org>, October 1998.
+
+   LibGTop is free software; you can redistribute it and/or modify it
+   under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License,
+   or (at your option) any later version.
+
+   LibGTop is distributed in the hope that it will be useful, but WITHOUT
+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+   for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with LibGTop; see the file COPYING. If not, write to the
+   Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.
+*/
+
+#include <config.h>
+#include <glibtop.h>
+#include <glibtop/error.h>
+#include <glibtop/ppp.h>
+
+static const unsigned long _glibtop_sysdeps_ppp = 0;
+
+/* Init function. */
+
+void
+_glibtop_init_ppp_s (glibtop *server)
+{
+	server->sysdeps.ppp = _glibtop_sysdeps_ppp;
+}
+
+/* Provides PPP/ISDN information. */
+
+void
+glibtop_get_ppp_s (glibtop *server, glibtop_ppp *buf, unsigned short device)
+{
+	memset (buf, 0, sizeof (glibtop_ppp));
+}
--- origsrc/libgtop-2.24.4/sysdeps/cygwin/procaffinity.c	1969-12-31 18:00:00.000000000 -0600
+++ src/libgtop-2.24.4/sysdeps/cygwin/procaffinity.c	2009-02-16 01:02:42.843750000 -0600
@@ -0,0 +1,40 @@
+/* Copyright (C) 2007 Benoît Dejean
+   This file is part of LibGTop 2.
+
+   LibGTop is free software; you can redistribute it and/or modify it
+   under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License,
+   or (at your option) any later version.
+
+   LibGTop is distributed in the hope that it will be useful, but WITHOUT
+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+   for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with LibGTop; see the file COPYING. If not, write to the
+   Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.
+*/
+
+#include <config.h>
+#include <glibtop/procaffinity.h>
+#include <glibtop/error.h>
+
+static const unsigned long _glibtop_sysdeps_proc_affinity = 0;
+
+void
+_glibtop_init_proc_affinity_s(glibtop *server)
+{
+  server->sysdeps.proc_affinity = _glibtop_sysdeps_proc_affinity;
+
+}
+
+
+guint16 *
+glibtop_get_proc_affinity_s(glibtop *server, glibtop_proc_affinity *buf, pid_t pid)
+{
+  memset(buf, 0, sizeof *buf);
+  return NULL;
+}
+
--- origsrc/libgtop-2.24.4/sysdeps/cygwin/procargs.c	1969-12-31 18:00:00.000000000 -0600
+++ src/libgtop-2.24.4/sysdeps/cygwin/procargs.c	2009-02-16 00:35:36.921875000 -0600
@@ -0,0 +1,70 @@
+/* Copyright (C) 1998-99 Martin Baulig
+   This file is part of LibGTop 1.0.
+
+   Contributed by Martin Baulig <martin@home-of-linux.org>, April 1998.
+
+   LibGTop is free software; you can redistribute it and/or modify it
+   under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License,
+   or (at your option) any later version.
+
+   LibGTop is distributed in the hope that it will be useful, but WITHOUT
+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+   for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with LibGTop; see the file COPYING. If not, write to the
+   Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.
+*/
+
+#include <config.h>
+#include <glibtop.h>
+#include <glibtop/error.h>
+#include <glibtop/procargs.h>
+
+static const unsigned long _glibtop_sysdeps_proc_args =
+(1L << GLIBTOP_PROC_ARGS_SIZE);
+
+/* Init function. */
+
+void
+_glibtop_init_proc_args_s (glibtop *server)
+{
+	server->sysdeps.proc_args = _glibtop_sysdeps_proc_args;
+}
+
+/* Provides detailed information about a process. */
+
+char *
+glibtop_get_proc_args_s (glibtop *server, glibtop_proc_args *buf,
+			 pid_t pid, unsigned max_len)
+{
+	char filename[48]; /* magiv */
+
+	char *args;
+	gsize length;
+	GError *error = NULL;
+
+	memset (buf, 0, sizeof (glibtop_proc_args));
+
+	sprintf (filename, "/proc/%d/cmdline", pid);
+
+	if(!g_file_get_contents(filename, &args, &length, &error)) {
+		g_error_free(error);
+		buf->size = 0;
+		return NULL;
+	}
+
+	if(max_len && max_len < length) {
+		args = g_realloc(args, max_len);
+		args[max_len - 1] = '\0';
+		length = max_len;
+	}
+
+	buf->size = length;
+	buf->flags = _glibtop_sysdeps_proc_args;
+
+	return args;
+}
--- origsrc/libgtop-2.24.4/sysdeps/cygwin/prockernel.c	1969-12-31 18:00:00.000000000 -0600
+++ src/libgtop-2.24.4/sysdeps/cygwin/prockernel.c	2009-02-16 01:03:23.531250000 -0600
@@ -0,0 +1,43 @@
+/* Copyright (C) 1998-99 Martin Baulig
+   This file is part of LibGTop 1.0.
+
+   Contributed by Martin Baulig <martin@home-of-linux.org>, April 1998.
+
+   LibGTop is free software; you can redistribute it and/or modify it
+   under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License,
+   or (at your option) any later version.
+
+   LibGTop is distributed in the hope that it will be useful, but WITHOUT
+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+   for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with LibGTop; see the file COPYING. If not, write to the
+   Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.
+*/
+
+#include <config.h>
+#include <glibtop.h>
+#include <glibtop/prockernel.h>
+
+static const unsigned long _glibtop_sysdeps_proc_kernel = 0;
+
+/* Init function. */
+
+void
+_glibtop_init_proc_kernel_s (glibtop *server)
+{
+	server->sysdeps.proc_kernel = _glibtop_sysdeps_proc_kernel;
+}
+
+/* Provides detailed information about a process. */
+
+void
+glibtop_get_proc_kernel_s (glibtop *server, glibtop_proc_kernel *buf,
+			   pid_t pid)
+{
+	memset (buf, 0, sizeof (glibtop_proc_kernel));
+}
--- origsrc/libgtop-2.24.4/sysdeps/cygwin/proclist.c	1969-12-31 18:00:00.000000000 -0600
+++ src/libgtop-2.24.4/sysdeps/cygwin/proclist.c	2009-02-16 01:05:44.656250000 -0600
@@ -0,0 +1,171 @@
+/* Copyright (C) 1998-99 Martin Baulig
+   This file is part of LibGTop 1.0.
+
+   Contributed by Martin Baulig <martin@home-of-linux.org>, April 1998.
+
+   LibGTop is free software; you can redistribute it and/or modify it
+   under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License,
+   or (at your option) any later version.
+
+   LibGTop is distributed in the hope that it will be useful, but WITHOUT
+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+   for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with LibGTop; see the file COPYING. If not, write to the
+   Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.
+*/
+
+#include <config.h>
+#include <glibtop/proclist.h>
+
+#include <glibtop/procuid.h>
+#include <glibtop/procstate.h>
+
+#include <sys/stat.h>
+#include <unistd.h>
+#include <dirent.h>
+#include <ctype.h>
+
+static const unsigned long _glibtop_sysdeps_proclist =
+(1L << GLIBTOP_PROCLIST_TOTAL) + (1L << GLIBTOP_PROCLIST_NUMBER) +
+(1L << GLIBTOP_PROCLIST_SIZE);
+
+/* Init function. */
+
+void
+_glibtop_init_proclist_s (glibtop *server)
+{
+	server->sysdeps.proclist = _glibtop_sysdeps_proclist;
+}
+
+/* Fetch list of currently running processes.
+ *
+ * The interface of this function is a little bit different from the others:
+ * buf->flags is only set if the call succeeded, in this case pids_chain,
+ * a list of the pids of all currently running processes is returned,
+ * buf->number is the number of elements of this list and buf->size is
+ * the size of one single element (sizeof (unsigned)). The total size is
+ * stored in buf->total.
+ *
+ * The calling function has to free the memory to which a pointer is returned.
+ *
+ * On error, NULL is returned and buf->flags is zero. */
+
+pid_t*
+glibtop_get_proclist_s (glibtop *server, glibtop_proclist *buf,
+			gint64 which, gint64 arg)
+{
+	DIR *proc;
+	struct dirent *entry;
+	GArray *pids;
+	glibtop_proc_uid procuid;
+	glibtop_proc_state procstate;
+	struct stat statb;
+
+	memset (buf, 0, sizeof (glibtop_proclist));
+
+	proc = opendir ("/proc");
+	if (!proc) return NULL;
+
+	if(fstat(dirfd(proc), &statb) != 0) return NULL;
+
+	pids = g_array_sized_new(FALSE, FALSE, sizeof(pid_t), statb.st_nlink);
+
+	/* read every every entry in /proc */
+
+	while((entry = readdir (proc))) {
+		pid_t pid;
+
+#ifdef DT_DIR
+		if (entry->d_type != DT_DIR)
+			continue;
+#endif
+
+		if (!(pid = strtoul(entry->d_name, NULL, 10)))
+			continue;
+
+		switch (which & GLIBTOP_KERN_PROC_MASK) {
+		case GLIBTOP_KERN_PROC_ALL:
+			break;
+		case GLIBTOP_KERN_PROC_PID:
+			if ((pid_t) arg != pid)
+				continue;
+			break;
+		case GLIBTOP_KERN_PROC_UID:
+		{
+			char path[32];
+			struct stat path_stat;
+
+			snprintf(path, sizeof path, "/proc/%u", (unsigned)pid);
+
+			if (stat(path, &path_stat))
+				continue;
+
+			if ((uid_t) arg != path_stat.st_uid)
+				continue;
+		}
+			break;
+		case GLIBTOP_KERN_PROC_PGRP:
+			/* Do you really, really need this ? */
+			glibtop_get_proc_uid_s (server, &procuid, pid);
+			if (procuid.flags & (1L << GLIBTOP_PROC_UID_PGRP))
+				if ((int) arg != procuid.pgrp)
+					continue;
+			break;
+		case GLIBTOP_KERN_PROC_SESSION:
+			/* Do you really, really need this ? */
+			glibtop_get_proc_uid_s (server, &procuid, pid);
+			if (procuid.flags & (1L << GLIBTOP_PROC_UID_SESSION))
+				if ((int) arg != procuid.session)
+					continue;
+			break;
+		case GLIBTOP_KERN_PROC_TTY:
+			/* Do you really, really need this ? */
+			glibtop_get_proc_uid_s (server, &procuid, pid);
+			if (procuid.flags & (1L << GLIBTOP_PROC_UID_TTY))
+				if ((int) arg != procuid.tty)
+					continue;
+			break;
+		case GLIBTOP_KERN_PROC_RUID:
+			/* Do you really, really need this ? */
+			glibtop_get_proc_uid_s (server, &procuid, pid);
+			if (procuid.flags & (1L << GLIBTOP_PROC_UID_EUID))
+				if ((int) arg != procuid.euid)
+					continue;
+			break;
+		}
+
+		if (which & GLIBTOP_EXCLUDE_NOTTY) {
+			glibtop_get_proc_uid_s (server, &procuid, pid);
+			if (procuid.flags & (1L << GLIBTOP_PROC_UID_TTY))
+				if (procuid.tty == -1) continue;
+		}
+
+		if (which & GLIBTOP_EXCLUDE_IDLE) {
+			glibtop_get_proc_state_s (server, &procstate, pid);
+			if (procstate.flags & (1L << GLIBTOP_PROC_STATE_STATE))
+				if (procstate.state != GLIBTOP_PROCESS_RUNNING) continue;
+		}
+
+		if (which & GLIBTOP_EXCLUDE_SYSTEM) {
+			glibtop_get_proc_uid_s (server, &procuid, pid);
+			if (procuid.flags & (1L << GLIBTOP_PROC_UID_UID))
+				if (procuid.uid == 0) continue;
+		}
+
+		g_array_append_val(pids, pid);
+	}
+
+	closedir (proc);
+
+	buf->flags = _glibtop_sysdeps_proclist;
+	buf->size = sizeof(pid_t);
+	buf->number = pids->len;
+	buf->total = buf->number * buf->size;
+
+	return (pid_t*)g_array_free(pids, FALSE);
+}
--- origsrc/libgtop-2.24.4/sysdeps/cygwin/procmap.c	1969-12-31 18:00:00.000000000 -0600
+++ src/libgtop-2.24.4/sysdeps/cygwin/procmap.c	2009-02-16 01:41:54.468750000 -0600
@@ -0,0 +1,196 @@
+/* Copyright (C) 1998-99 Martin Baulig
+   This file is part of LibGTop 1.0.
+
+   Contributed by Martin Baulig <martin@home-of-linux.org>, April 1998.
+
+   LibGTop is free software; you can redistribute it and/or modify it
+   under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License,
+   or (at your option) any later version.
+
+   LibGTop is distributed in the hope that it will be useful, but WITHOUT
+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+   for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with LibGTop; see the file COPYING. If not, write to the
+   Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.
+*/
+
+#include <config.h>
+#include <glib.h>
+
+#include <glibtop.h>
+#include <glibtop/error.h>
+#include <glibtop/procmap.h>
+
+#include <stddef.h>
+
+#include "glibtop_private.h"
+
+#define MKDEV(ma,mi)    (((ma) << 20) | (mi))
+
+#define  MAPS_FILE "/proc/%u/maps"
+
+
+#define PROC_MAPS_FORMAT "%16" G_GINT64_MODIFIER "x-%16" G_GINT64_MODIFIER "x %4c %16" G_GINT64_MODIFIER "x %02hx:%02hx %" G_GINT64_MODIFIER "u%*[ ]%n"
+
+
+static const unsigned long _glibtop_sysdeps_proc_map =
+(1L << GLIBTOP_PROC_MAP_NUMBER) + (1L << GLIBTOP_PROC_MAP_TOTAL) +
+(1L << GLIBTOP_PROC_MAP_SIZE);
+
+static const unsigned long _glibtop_sysdeps_map_entry =
+(1L << GLIBTOP_MAP_ENTRY_START) + (1L << GLIBTOP_MAP_ENTRY_END) +
+(1L << GLIBTOP_MAP_ENTRY_OFFSET) + (1L << GLIBTOP_MAP_ENTRY_PERM) +
+(1L << GLIBTOP_MAP_ENTRY_INODE) + (1L << GLIBTOP_MAP_ENTRY_DEVICE) +
+(1L << GLIBTOP_MAP_ENTRY_FILENAME);
+
+
+/* Init function. */
+
+void
+_glibtop_init_proc_map_s (glibtop *server)
+{
+	server->sysdeps.proc_map = _glibtop_sysdeps_proc_map;
+}
+
+/* Provides detailed information about a process. */
+
+
+
+struct smap_value {
+	char name[16];
+	size_t name_len;
+	ptrdiff_t offset;
+};
+
+static int
+compare(const void* a_key, const void* a_smap)
+{
+	const char* key = a_key;
+	const struct smap_value* smap = a_smap;
+	return strncmp(key, smap->name, smap->name_len);
+}
+
+
+static gboolean
+is_smap_value(const char* s)
+{
+	for ( ; *s; ++s) {
+
+		if (isspace(*s))
+			return FALSE;
+
+		if (*s == ':')
+			return TRUE;
+	}
+
+	return FALSE;
+}
+
+
+glibtop_map_entry *
+glibtop_get_proc_map_s (glibtop *server, glibtop_proc_map *buf,	pid_t pid)
+{
+	char procfilename[GLIBTOP_MAP_FILENAME_LEN+1];
+
+	/*
+	  default size of 100 maybe inaccurate.
+	  It's the average number of entry per process on my laptop
+	*/
+
+	GArray *entry_list = g_array_sized_new(FALSE, FALSE,
+					       sizeof(glibtop_map_entry),
+					       100);
+	FILE *maps;
+	const char *filename;
+	char *line = NULL;
+	size_t line_size = 0;
+
+	memset (buf, 0, sizeof (glibtop_proc_map));
+
+	filename = MAPS_FILE;
+
+	snprintf (procfilename, sizeof procfilename, filename, (unsigned)pid);
+
+	if((maps = fopen (procfilename, "r")) == NULL) {
+	  return (glibtop_map_entry*) g_array_free(entry_list, TRUE);
+	}
+
+	while(TRUE)
+	{
+		unsigned long perm;
+		guint len;
+		int line_end;
+
+		unsigned short dev_major, dev_minor;
+		guint64 start, end, offset, inode;
+		char flags[4];
+		char *filename;
+
+		glibtop_map_entry *entry;
+
+		if (getline(&line, &line_size, maps) == -1)
+			break;
+
+	new_entry_line:
+
+		if (sscanf(line, PROC_MAPS_FORMAT,
+			   &start, &end, flags, &offset,
+			   &dev_major, &dev_minor, &inode, &line_end) != 7)
+			continue;
+
+		filename = line + line_end;
+		g_strstrip(filename);
+
+		/* Compute access permissions. */
+		perm = 0;
+
+		if (flags [0] == 'r')
+			perm |= GLIBTOP_MAP_PERM_READ;
+
+		if (flags [1] == 'w')
+			perm |= GLIBTOP_MAP_PERM_WRITE;
+
+		if (flags [2] == 'x')
+			perm |= GLIBTOP_MAP_PERM_EXECUTE;
+
+		if (flags [3] == 's')
+			perm |= GLIBTOP_MAP_PERM_SHARED;
+		else if (flags [3] == 'p')
+			perm |= GLIBTOP_MAP_PERM_PRIVATE;
+
+		/*
+		  avoid copying the entry, grow by 1 and point to the last
+		  element.
+		*/
+		len = entry_list->len;
+		g_array_set_size(entry_list, len + 1);
+		entry = &g_array_index(entry_list, glibtop_map_entry, len);
+
+		entry->flags = _glibtop_sysdeps_map_entry;
+		entry->start = start;
+		entry->end = end;
+		entry->offset = offset;
+		entry->perm = perm;
+		entry->device = MKDEV(dev_major, dev_minor);
+		entry->inode = inode;
+		g_strlcpy(entry->filename, filename, sizeof entry->filename);
+	}
+
+eof:
+
+	free(line);
+	fclose (maps);
+
+	buf->flags = _glibtop_sysdeps_proc_map;
+
+	buf->number = entry_list->len;
+	buf->size = sizeof (glibtop_map_entry);
+	buf->total = buf->number * buf->size;
+
+	return (glibtop_map_entry*) g_array_free(entry_list, FALSE);
+}
--- origsrc/libgtop-2.24.4/sysdeps/cygwin/procmem.c	1969-12-31 18:00:00.000000000 -0600
+++ src/libgtop-2.24.4/sysdeps/cygwin/procmem.c	2009-02-16 01:10:17.796875000 -0600
@@ -0,0 +1,69 @@
+/* Copyright (C) 1998-99 Martin Baulig
+   This file is part of LibGTop 1.0.
+
+   Contributed by Martin Baulig <martin@home-of-linux.org>, April 1998.
+
+   LibGTop is free software; you can redistribute it and/or modify it
+   under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License,
+   or (at your option) any later version.
+
+   LibGTop is distributed in the hope that it will be useful, but WITHOUT
+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+   for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with LibGTop; see the file COPYING. If not, write to the
+   Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.
+*/
+
+#include <config.h>
+#include <glibtop.h>
+#include <glibtop/error.h>
+#include <glibtop/procmem.h>
+
+#include "glibtop_private.h"
+
+static const unsigned long _glibtop_sysdeps_proc_mem =
+(1L << GLIBTOP_PROC_MEM_SIZE) + (1L << GLIBTOP_PROC_MEM_RESIDENT) +
+(1L << GLIBTOP_PROC_MEM_SHARE);
+
+
+/* Init function. */
+
+void
+_glibtop_init_proc_mem_s (glibtop *server)
+{
+	server->sysdeps.proc_mem = _glibtop_sysdeps_proc_mem;
+}
+
+/* Provides detailed information about a process. */
+
+void
+glibtop_get_proc_mem_s (glibtop *server, glibtop_proc_mem *buf, pid_t pid)
+{
+	char buffer [BUFSIZ], *p;
+	const size_t pagesize = get_page_size();
+
+	memset (buf, 0, sizeof (glibtop_proc_mem));
+
+	if (proc_statm_to_buffer(buffer, sizeof buffer, pid))
+		return;
+
+	buf->size     = strtoull (buffer, &p, 0);
+	buf->resident = strtoull (p, &p, 0);
+	buf->share    = strtoull (p, &p, 0);
+
+	buf->size     *= pagesize;
+	buf->resident *= pagesize;
+	buf->share    *= pagesize;
+
+	/* dummy values */
+	buf->vsize = buf->size;
+	buf->rss_rlim = ~0;
+
+	buf->flags |= _glibtop_sysdeps_proc_mem;
+	buf->rss = buf->resident;
+}
--- origsrc/libgtop-2.24.4/sysdeps/cygwin/procopenfiles.c	1969-12-31 18:00:00.000000000 -0600
+++ src/libgtop-2.24.4/sysdeps/cygwin/procopenfiles.c	2009-02-16 01:38:27.171875000 -0600
@@ -0,0 +1,328 @@
+/* Copyright (C) 1998-99 Martin Baulig
+   Copyright (C) 2004 Nicolás Lichtmaier
+   This file is part of LibGTop 1.0.
+
+   Modified by Nicolás Lichtmaier to give a process open files.
+
+   Contributed by Martin Baulig <martin@home-of-linux.org>, April 1998.
+
+   LibGTop is free software; you can redistribute it and/or modify it
+   under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License,
+   or (at your option) any later version.
+
+   LibGTop is distributed in the hope that it will be useful, but WITHOUT
+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+   for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with LibGTop; see the file COPYING. If not, write to the
+   Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.
+*/
+
+#include <config.h>
+#include <glibtop.h>
+#include <glibtop/error.h>
+#include <glibtop/procopenfiles.h>
+#include <sys/types.h>
+#include <dirent.h>
+#include <string.h>
+#include <stdio.h>
+#include <arpa/inet.h>
+
+#include "glibtop_private.h"
+
+static const unsigned long _glibtop_sysdeps_proc_open_files =
+(1L << GLIBTOP_PROC_OPEN_FILES_NUMBER)|
+(1L << GLIBTOP_PROC_OPEN_FILES_TOTAL)|
+(1L << GLIBTOP_PROC_OPEN_FILES_SIZE);
+
+/* Init function. */
+
+void
+_glibtop_init_proc_open_files_s (glibtop *server)
+{
+	server->sysdeps.proc_open_files = _glibtop_sysdeps_proc_open_files;
+}
+
+
+
+typedef void (*LineParser)(GHashTable *dict, const char *line);
+
+
+static void
+parse_file(const char *filename, LineParser parser, GHashTable *dict)
+{
+	FILE *f;
+	char *line = NULL;
+	size_t size = 0;
+
+	f = fopen(filename, "r");
+
+	if(!f) {
+		g_warning("Cannot open '%s'", filename);
+		return;
+	}
+
+
+	/* skip the first line */
+	if (getline(&line, &size, f) == -1)
+		goto eof;
+
+	while (getline(&line, &size, f) != -1)
+		parser(dict, line);
+
+ eof:
+	free(line);
+	fclose(f);
+}
+
+
+static GHashTable*
+get_all(const char *filename, LineParser parser)
+{
+	GHashTable *dict;
+
+	dict = g_hash_table_new_full(g_direct_hash, g_direct_equal,
+				     NULL, g_free);
+
+	parse_file(filename, parser, dict);
+
+	return dict;
+}
+
+
+
+
+
+struct Inet6SocketEntry
+{
+	char host[GLIBTOP_OPEN_DEST_HOST_LEN + 1];
+	int port;
+};
+
+
+#ifdef AF_INET6
+static void
+inet6_socket_parser(GHashTable *dict, const char* line)
+{
+	struct Inet6SocketEntry *se;
+	int sock;
+	struct in6_addr addr;
+
+	se = g_malloc0(sizeof *se);
+
+	if(sscanf(line, "%*d: %*s %8x%8x%8x%8x:%4x %*x %*x:%*x %*x:%*x %*d %*d %*d %d",
+		  &addr.s6_addr32[0], &addr.s6_addr32[1], &addr.s6_addr32[2],
+		  &addr.s6_addr32[3], &se->port, &sock) != 6)
+		goto error;
+
+	if(!inet_ntop(AF_INET6, &addr, se->host, sizeof se->host))
+		goto error;
+
+	g_hash_table_insert(dict, GINT_TO_POINTER(sock), se);
+	return;
+
+ error:
+	g_free(se);
+}
+
+
+static inline GHashTable *
+get_all_inet6_sockets()
+{
+	return get_all("/proc/net/tcp6", inet6_socket_parser);
+}
+#endif
+
+
+
+
+
+struct InetSocketEntry
+{
+	char host[GLIBTOP_OPEN_DEST_HOST_LEN + 1];
+	int port;
+};
+
+
+static void
+inet_socket_parser(GHashTable *dict, const char* line)
+{
+	struct InetSocketEntry *se;
+	int sock;
+	unsigned addr;
+
+	se = g_malloc0(sizeof *se);
+
+	if(sscanf(line, "%*d: %*x:%*x %8x:%4x %*x %*x:%*x %*x:%*x %*d %*d %*d %d",
+		  &addr, &se->port, &sock) != 3)
+		goto error;
+
+	if(!inet_ntop(AF_INET, &addr, se->host, sizeof se->host))
+		goto error;
+
+	g_hash_table_insert(dict, GINT_TO_POINTER(sock), se);
+	return;
+
+ error:
+	g_free(se);
+}
+
+
+static inline GHashTable *
+get_all_inet_sockets()
+{
+	return get_all("/proc/net/tcp", inet_socket_parser);
+}
+
+
+
+
+
+struct LocalSocketEntry
+{
+	char name[GLIBTOP_OPEN_DEST_HOST_LEN + 1];
+};
+
+
+static void
+local_socket_parser(GHashTable *dict, const char *line)
+{
+	int sock;
+	struct LocalSocketEntry *use;
+	char *p;
+
+	use = g_malloc0(sizeof *use);
+
+	/* dfaf1640: 00000003 00000000 00000000 0001 03  6457 /dev/log */
+	p = skip_multiple_token(line, 6);
+
+	sock = strtoul(p, &p, 10);
+	g_strlcpy(use->name, p, sizeof use->name);
+	g_strstrip(use->name);
+	g_hash_table_insert(dict, GINT_TO_POINTER(sock), use);
+}
+
+
+static inline GHashTable *
+get_all_local_sockets()
+{
+	return get_all("/proc/net/unix", local_socket_parser);
+}
+
+
+
+/* Provides detailed information about a process' open files */
+
+glibtop_open_files_entry *
+glibtop_get_proc_open_files_s (glibtop *server, glibtop_proc_open_files *buf,	pid_t pid)
+{
+	char fn [BUFSIZ];
+	GArray *entries;
+	GHashTable *inet6_sockets = NULL, *inet_sockets = NULL, *local_sockets = NULL;
+	struct dirent *direntry;
+	DIR *dir;
+
+	memset (buf, 0, sizeof (glibtop_proc_open_files));
+
+	sprintf (fn, "/proc/%d/fd", pid);
+
+	dir = opendir (fn);
+	if (!dir) return NULL;
+
+	entries = g_array_new(FALSE, FALSE, sizeof(glibtop_open_files_entry));
+
+	while((direntry = readdir(dir))) {
+		char tgt [BUFSIZ];
+		glibtop_open_files_entry entry = {0};
+
+		if(direntry->d_name[0] == '.')
+			continue;
+
+		g_snprintf(fn, sizeof fn, "/proc/%d/fd/%s",
+			   pid, direntry->d_name);
+
+		if (!safe_readlink(fn, tgt, sizeof tgt))
+			continue;
+
+		entry.fd = atoi(direntry->d_name);
+
+		if(g_str_has_prefix(tgt, "socket:["))
+		{
+			int sockfd;
+			struct Inet6SocketEntry *i6se;
+			struct InetSocketEntry *ise;
+			struct LocalSocketEntry *lse;
+
+#ifdef AF_INET6
+			if(!inet6_sockets) inet6_sockets = get_all_inet6_sockets();
+#endif
+			if(!inet_sockets) inet_sockets = get_all_inet_sockets();
+			if(!local_sockets) local_sockets = get_all_local_sockets();
+
+			sockfd = atoi(tgt + 8);
+
+			i6se = g_hash_table_lookup(inet6_sockets,
+						 GINT_TO_POINTER(sockfd));
+
+			if(i6se) {
+				entry.type = GLIBTOP_FILE_TYPE_INET6SOCKET;
+				entry.info.sock.dest_port = i6se->port;
+				g_strlcpy(entry.info.sock.dest_host, i6se->host,
+					  sizeof entry.info.sock.dest_host);
+				goto found;
+			}
+
+			ise = g_hash_table_lookup(inet_sockets,
+						 GINT_TO_POINTER(sockfd));
+
+			if(ise) {
+				entry.type = GLIBTOP_FILE_TYPE_INETSOCKET;
+				entry.info.sock.dest_port = ise->port;
+				g_strlcpy(entry.info.sock.dest_host, ise->host,
+					  sizeof entry.info.sock.dest_host);
+				goto found;
+			}
+
+			lse = g_hash_table_lookup(local_sockets,
+						  GINT_TO_POINTER(sockfd));
+
+			if(lse) {
+				entry.type = GLIBTOP_FILE_TYPE_LOCALSOCKET;
+				g_strlcpy(entry.info.localsock.name, lse->name,
+					  sizeof entry.info.localsock.name);
+				goto found;
+			}
+
+		found:
+			(void)0; /* kills warning */
+		}
+		else if(g_str_has_prefix(tgt, "pipe:["))
+		{
+			entry.type = GLIBTOP_FILE_TYPE_PIPE;
+		}
+		else
+		{
+			entry.type = GLIBTOP_FILE_TYPE_FILE;
+			g_strlcpy(entry.info.file.name, tgt, sizeof entry.info.file.name);
+		}
+
+		g_array_append_val(entries, entry);
+	}
+
+	closedir (dir);
+
+	if(inet_sockets) g_hash_table_destroy(inet_sockets);
+	if(inet6_sockets) g_hash_table_destroy(inet6_sockets);
+	if(local_sockets) g_hash_table_destroy(local_sockets);
+
+	buf->flags = _glibtop_sysdeps_proc_open_files;
+	buf->number = entries->len;
+	buf->size = sizeof(glibtop_open_files_entry);
+	buf->total = buf->number * buf->size;
+
+	return (glibtop_open_files_entry*)g_array_free(entries, FALSE);
+}
--- origsrc/libgtop-2.24.4/sysdeps/cygwin/procsegment.c	1969-12-31 18:00:00.000000000 -0600
+++ src/libgtop-2.24.4/sysdeps/cygwin/procsegment.c	2009-02-16 01:19:39.296875000 -0600
@@ -0,0 +1,88 @@
+/* Copyright (C) 1998-99 Martin Baulig
+   This file is part of LibGTop 1.0.
+
+   Contributed by Martin Baulig <martin@home-of-linux.org>, April 1998.
+
+   LibGTop is free software; you can redistribute it and/or modify it
+   under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License,
+   or (at your option) any later version.
+
+   LibGTop is distributed in the hope that it will be useful, but WITHOUT
+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+   for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with LibGTop; see the file COPYING. If not, write to the
+   Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.
+*/
+
+#include <config.h>
+#include <glibtop/error.h>
+#include <glibtop/procsegment.h>
+
+#include "glibtop_private.h"
+
+static const unsigned long _glibtop_sysdeps_proc_segment =
+(1L << GLIBTOP_PROC_SEGMENT_START_CODE) +
+(1L << GLIBTOP_PROC_SEGMENT_END_CODE) +
+(1L << GLIBTOP_PROC_SEGMENT_START_STACK);
+
+static const unsigned long _glibtop_sysdeps_proc_segment_statm =
+(1L << GLIBTOP_PROC_SEGMENT_TEXT_RSS) +
+(1L << GLIBTOP_PROC_SEGMENT_DATA_RSS) +
+(1L << GLIBTOP_PROC_SEGMENT_DIRTY_SIZE);
+
+/* Init function. */
+
+void
+_glibtop_init_proc_segment_s (glibtop *server)
+{
+	server->sysdeps.proc_segment = _glibtop_sysdeps_proc_segment |
+	  _glibtop_sysdeps_proc_segment_statm;
+}
+
+/* Provides detailed information about a process. */
+
+void
+glibtop_get_proc_segment_s (glibtop *server, glibtop_proc_segment *buf,
+			    pid_t pid)
+{
+	char buffer [BUFSIZ], *p;
+	const size_t pagesize = get_page_size();
+
+	memset (buf, 0, sizeof (glibtop_proc_segment));
+
+	if (proc_stat_to_buffer(buffer, sizeof buffer, pid))
+		return;
+
+	p = proc_stat_after_cmd (buffer);
+	if (!p) return;
+
+	p = skip_multiple_token (p, 23);
+
+	buf->start_code  = strtoull (p, &p, 0);
+	buf->end_code    = strtoull (p, &p, 0);
+	buf->start_stack = strtoull (p, &p, 0);
+
+	buf->flags = _glibtop_sysdeps_proc_segment;
+
+	if (proc_statm_to_buffer(buffer, sizeof buffer, pid))
+		return;
+
+	p = skip_multiple_token (buffer, 3);
+
+	buf->text_rss   = strtoull (p, &p, 0);
+	buf->shlib_rss  = strtoull (p, &p, 0);
+	buf->data_rss   = strtoull (p, &p, 0);
+	buf->dirty_size = strtoull (p, &p, 0);
+
+	buf->text_rss   *= pagesize;
+	buf->shlib_rss  *= pagesize;
+	buf->data_rss   *= pagesize;
+	buf->dirty_size *= pagesize;
+
+	buf->flags |= _glibtop_sysdeps_proc_segment_statm;
+}
--- origsrc/libgtop-2.24.4/sysdeps/cygwin/procsignal.c	1969-12-31 18:00:00.000000000 -0600
+++ src/libgtop-2.24.4/sysdeps/cygwin/procsignal.c	2009-02-16 00:35:36.968750000 -0600
@@ -0,0 +1,64 @@
+/* Copyright (C) 1998-99 Martin Baulig
+   This file is part of LibGTop 1.0.
+
+   Contributed by Martin Baulig <martin@home-of-linux.org>, April 1998.
+
+   LibGTop is free software; you can redistribute it and/or modify it
+   under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License,
+   or (at your option) any later version.
+
+   LibGTop is distributed in the hope that it will be useful, but WITHOUT
+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+   for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with LibGTop; see the file COPYING. If not, write to the
+   Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.
+*/
+
+#include <config.h>
+#include <glibtop.h>
+#include <glibtop/error.h>
+#include <glibtop/procsignal.h>
+
+#include "glibtop_private.h"
+
+static const unsigned long _glibtop_sysdeps_proc_signal =
+(1L << GLIBTOP_PROC_SIGNAL_SIGNAL) + (1L << GLIBTOP_PROC_SIGNAL_BLOCKED) +
+(1L << GLIBTOP_PROC_SIGNAL_SIGIGNORE) + (1L << GLIBTOP_PROC_SIGNAL_SIGCATCH);
+
+/* Init function. */
+
+void
+_glibtop_init_proc_signal_s (glibtop *server)
+{
+	server->sysdeps.proc_signal = _glibtop_sysdeps_proc_signal;
+}
+
+/* Provides detailed information about a process. */
+
+void
+glibtop_get_proc_signal_s (glibtop *server, glibtop_proc_signal *buf, pid_t pid)
+{
+	char buffer [BUFSIZ], *p;
+
+	memset (buf, 0, sizeof (glibtop_proc_signal));
+
+	if (proc_stat_to_buffer(buffer, sizeof buffer, pid))
+		return;
+
+	p = proc_stat_after_cmd (buffer);
+	if (!p) return;
+
+	p = skip_multiple_token (p, 28);
+
+	buf->signal [0]    = strtoull (p, &p, 0);
+	buf->blocked [0]   = strtoull (p, &p, 0);
+	buf->sigignore [0] = strtoull (p, &p, 0);
+	buf->sigcatch [0]  = strtoull (p, &p, 0);
+
+	buf->flags = _glibtop_sysdeps_proc_signal;
+}
--- origsrc/libgtop-2.24.4/sysdeps/cygwin/procstate.c	1969-12-31 18:00:00.000000000 -0600
+++ src/libgtop-2.24.4/sysdeps/cygwin/procstate.c	2009-02-16 00:35:36.968750000 -0600
@@ -0,0 +1,120 @@
+/* Copyright (C) 1998-99 Martin Baulig
+   This file is part of LibGTop 1.0.
+
+   Contributed by Martin Baulig <martin@home-of-linux.org>, April 1998.
+
+   LibGTop is free software; you can redistribute it and/or modify it
+   under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License,
+   or (at your option) any later version.
+
+   LibGTop is distributed in the hope that it will be useful, but WITHOUT
+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+   for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with LibGTop; see the file COPYING. If not, write to the
+   Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.
+*/
+
+#include <config.h>
+#include <glibtop.h>
+#include <glibtop/error.h>
+#include <glibtop/procstate.h>
+
+#include "glibtop_private.h"
+
+#include <sys/stat.h>
+
+static const unsigned long _glibtop_sysdeps_proc_state =
+(1L << GLIBTOP_PROC_STATE_CMD) + (1L << GLIBTOP_PROC_STATE_STATE);
+
+static const unsigned long _glibtop_sysdeps_proc_state_uid =
+(1L << GLIBTOP_PROC_STATE_UID) + (1L << GLIBTOP_PROC_STATE_GID);
+
+/* Init function. */
+
+void
+_glibtop_init_proc_state_s (glibtop *server)
+{
+	server->sysdeps.proc_state = _glibtop_sysdeps_proc_state |
+		_glibtop_sysdeps_proc_state_uid;
+}
+
+/* Provides detailed information about a process. */
+
+void
+glibtop_get_proc_state_s (glibtop *server, glibtop_proc_state *buf, pid_t pid)
+{
+	char buffer [BUFSIZ], *p;
+	struct stat statb;
+
+	memset (buf, 0, sizeof (glibtop_proc_state));
+
+	/* IMPORTANT NOTICE: For security reasons it is extremely important
+	 *                   that the 'uid' and 'gid' fields have correct
+	 *                   values; NEVER set their flags values if this
+	 *                   is not the case !!! */
+
+	sprintf (buffer, "/proc/%d", pid);
+
+	if (stat (buffer, &statb))
+		return;
+
+	/* For security reasons we use stat () since it is
+	 * more failsafe than parsing the file. */
+
+	buf->uid = statb.st_uid;
+	buf->gid = statb.st_gid;
+
+	buf->flags = _glibtop_sysdeps_proc_state_uid;
+
+	/* Now we read the remaining fields. */
+
+	if (proc_stat_to_buffer(buffer, sizeof buffer, pid))
+		return;
+
+	p = proc_stat_after_cmd(buffer);
+	p = next_token(p);
+
+	switch(*p)
+	  {
+	  case 'R':
+	    buf->state = GLIBTOP_PROCESS_RUNNING;
+	    break;
+
+	  case 'Z':
+	    buf->state = GLIBTOP_PROCESS_ZOMBIE;
+	    break;
+
+	  case 'S':
+	    buf->state = GLIBTOP_PROCESS_INTERRUPTIBLE;
+	    break;
+
+	  case 'T':
+	    buf->state = GLIBTOP_PROCESS_STOPPED;
+	    break;
+
+	  case 'D':
+	    buf->state = GLIBTOP_PROCESS_UNINTERRUPTIBLE;
+	    break;
+
+	  case 'W':
+	    buf->state = GLIBTOP_PROCESS_SWAPPING;
+	    break;
+
+	  case 'X':
+	    buf->state = GLIBTOP_PROCESS_DEAD;
+	    break;
+	  }
+
+	p = skip_token (buffer); /* pid */
+	if (G_UNLIKELY(*p++ != '('))
+		glibtop_error_r (server, "Bad data in /proc/%d/stat", pid);
+
+	g_strlcpy (buf->cmd, p, sizeof buf->cmd);
+
+	buf->flags |= _glibtop_sysdeps_proc_state;
+}
--- origsrc/libgtop-2.24.4/sysdeps/cygwin/proctime.c	1969-12-31 18:00:00.000000000 -0600
+++ src/libgtop-2.24.4/sysdeps/cygwin/proctime.c	2009-02-16 01:21:05.187500000 -0600
@@ -0,0 +1,109 @@
+/* Copyright (C) 1998-99 Martin Baulig
+   This file is part of LibGTop 1.0.
+
+   Contributed by Martin Baulig <martin@home-of-linux.org>, April 1998.
+
+   LibGTop is free software; you can redistribute it and/or modify it
+   under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License,
+   or (at your option) any later version.
+
+   LibGTop is distributed in the hope that it will be useful, but WITHOUT
+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+   for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with LibGTop; see the file COPYING. If not, write to the
+   Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.
+*/
+
+#include <config.h>
+#include <glibtop.h>
+#include <glibtop/error.h>
+#include <glibtop/proctime.h>
+#include <glibtop/uptime.h>
+
+#include "glibtop_private.h"
+
+static const unsigned long _glibtop_sysdeps_proc_time =
+(1L << GLIBTOP_PROC_TIME_UTIME) + (1L << GLIBTOP_PROC_TIME_CUTIME) +
+(1L << GLIBTOP_PROC_TIME_RTIME) +
+(1L << GLIBTOP_PROC_TIME_STIME) + (1L << GLIBTOP_PROC_TIME_CSTIME) +
+(1L << GLIBTOP_PROC_TIME_FREQUENCY) + (1L << GLIBTOP_PROC_TIME_TIMEOUT) +
+(1L << GLIBTOP_PROC_TIME_IT_REAL_VALUE) + (1L << GLIBTOP_PROC_TIME_START_TIME);
+
+static const unsigned long _glibtop_sysdeps_proc_time_smp =
+(1L << GLIBTOP_PROC_TIME_XCPU_UTIME) + (1L << GLIBTOP_PROC_TIME_XCPU_STIME);
+
+/* Init function. */
+
+void
+_glibtop_init_proc_time_s (glibtop *server)
+{
+	server->sysdeps.proc_time = _glibtop_sysdeps_proc_time;
+
+	if (server->ncpu)
+		server->sysdeps.proc_time |= _glibtop_sysdeps_proc_time_smp;
+}
+
+/* Provides detailed information about a process. */
+
+void
+glibtop_get_proc_time_s (glibtop *server, glibtop_proc_time *buf, pid_t pid)
+{
+	char buffer [BUFSIZ], *p;
+	int i;
+
+	memset (buf, 0, sizeof (glibtop_proc_time));
+
+	if (proc_stat_to_buffer(buffer, sizeof buffer, pid))
+		return;
+
+	p = proc_stat_after_cmd (buffer);
+	if (!p) return;
+
+	p = skip_multiple_token (p, 11);
+
+	/* clock_t  (1/100 s) */
+	buf->utime  = strtoull (p, &p, 0);
+	buf->stime  = strtoull (p, &p, 0);
+	buf->rtime = buf->utime + buf->stime;
+
+	buf->cutime = strtoull (p, &p, 0);
+	buf->cstime = strtoull (p, &p, 0);
+
+	p = skip_multiple_token (p, 3);
+
+	buf->it_real_value = strtoull (p, &p, 0);
+
+	/* seconds since epoch */
+	{
+	  buf->start_time = get_boot_time(server) + strtoull (p, &p, 0) / 100;
+	}
+
+	buf->frequency = 100;
+
+	buf->flags = _glibtop_sysdeps_proc_time;
+
+	if (!server->ncpu)
+		return;
+
+	if (proc_file_to_buffer(buffer, sizeof buffer, "/proc/%d/cpu", pid))
+		return;
+
+	p = skip_multiple_token (p, 3);
+
+	for (i = 0; i <= server->ncpu; i++) {
+
+		if (!check_cpu_line_warn(server, p + 1, i))
+			break;
+
+		p = skip_token(p);
+		buf->xcpu_utime [i] = strtoull (p, &p, 0);
+		buf->xcpu_stime [i] = strtoull (p, &p, 0);
+	}
+
+	buf->flags |= _glibtop_sysdeps_proc_time_smp;
+}
--- origsrc/libgtop-2.24.4/sysdeps/cygwin/procuid.c	1969-12-31 18:00:00.000000000 -0600
+++ src/libgtop-2.24.4/sysdeps/cygwin/procuid.c	2009-02-16 01:26:36.625000000 -0600
@@ -0,0 +1,115 @@
+/* Copyright (C) 1998-99 Martin Baulig
+   This file is part of LibGTop 1.0.
+
+   Contributed by Martin Baulig <martin@home-of-linux.org>, April 1998.
+
+   LibGTop is free software; you can redistribute it and/or modify it
+   under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License,
+   or (at your option) any later version.
+
+   LibGTop is distributed in the hope that it will be useful, but WITHOUT
+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+   for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with LibGTop; see the file COPYING. If not, write to the
+   Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.
+*/
+
+#include <config.h>
+#include <glibtop.h>
+#include <glibtop/error.h>
+#include <glibtop/procuid.h>
+
+#include "glibtop_private.h"
+
+static const unsigned long _glibtop_sysdeps_proc_uid =
+(1L << GLIBTOP_PROC_UID_UID) + (1L << GLIBTOP_PROC_UID_EUID) +
+(1L << GLIBTOP_PROC_UID_GID) + (1L << GLIBTOP_PROC_UID_EGID);
+
+static const unsigned long _glibtop_sysdeps_proc_uid_stat =
+(1L << GLIBTOP_PROC_UID_PID) + (1L << GLIBTOP_PROC_UID_PPID) +
+(1L << GLIBTOP_PROC_UID_PGRP) + (1L << GLIBTOP_PROC_UID_SESSION) +
+(1L << GLIBTOP_PROC_UID_TTY) + (1L << GLIBTOP_PROC_UID_TPGID) +
+(1L << GLIBTOP_PROC_UID_PRIORITY) + (1L << GLIBTOP_PROC_UID_NICE);
+
+
+/* Init function. */
+
+void
+_glibtop_init_proc_uid_s (glibtop *server)
+{
+	server->sysdeps.proc_uid = _glibtop_sysdeps_proc_uid |
+		_glibtop_sysdeps_proc_uid_stat;
+}
+
+/* Provides detailed information about a process. */
+
+void
+glibtop_get_proc_uid_s (glibtop *server, glibtop_proc_uid *buf, pid_t pid)
+{
+	char buffer [BUFSIZ], *p;
+
+	memset (buf, 0, sizeof (glibtop_proc_uid));
+
+	if (proc_status_to_buffer(buffer, sizeof buffer, pid))
+		return;
+
+	/* Search substring 'Pid:' */
+
+	p = strstr (buffer, "\nPid:");
+	if (!p) return;
+
+	p = skip_token (p); /* "Pid:" */
+	buf->pid = strtol (p, &p, 0);
+
+	p = skip_token (p); /* "PPid:" */
+	buf->ppid = strtol (p, &p, 0);
+
+	/* Maybe future Linux versions place something between
+	 * "PPid" and "Uid", so we catch this here. */
+	p = strstr (p, "\nUid:");
+	if (!p) return;
+
+	p = skip_token (p); /* "Uid:" */
+	buf->uid  = strtol (p, &p, 0);
+	buf->euid = strtol (p, &p, 0);
+
+	/* We don't know how many entries on the "Uid:" line
+	 * future Linux version will have, so we catch this here. */
+	p = strstr (p, "\nGid:");
+	if (!p) return;
+
+	p = skip_token (p); /* "Gid:" */
+	buf->gid  = strtol (p, &p, 0);
+	buf->egid = strtol (p, &p, 0);
+
+	buf->flags = _glibtop_sysdeps_proc_uid;
+
+	if (proc_stat_to_buffer(buffer, sizeof buffer, pid))
+		return;
+
+	p = proc_stat_after_cmd (buffer);
+	if (!p) return;
+
+	p = skip_multiple_token (p, 2);
+
+	buf->pgrp    = strtol (p, &p, 0);
+	buf->session = strtol (p, &p, 0);
+	buf->tty     = strtol (p, &p, 0);
+	buf->tpgid   = strtol (p, &p, 0);
+
+	p = skip_multiple_token (p, 9);
+
+	buf->priority = strtol (p, &p, 0);
+	buf->nice     = strtol (p, &p, 0);
+
+	if (buf->tty == 0)
+		/* the old notty val, update elsewhere bef. moving to 0 */
+		buf->tty = -1;
+
+	buf->flags |= _glibtop_sysdeps_proc_uid_stat;
+}
--- origsrc/libgtop-2.24.4/sysdeps/cygwin/procwd.c	1969-12-31 18:00:00.000000000 -0600
+++ src/libgtop-2.24.4/sysdeps/cygwin/procwd.c	2009-02-16 00:35:36.984375000 -0600
@@ -0,0 +1,99 @@
+/* Copyright (C) 2007 Benoît Dejean
+   This file is part of LibGTop 2.
+
+   LibGTop is free software; you can redistribute it and/or modify it
+   under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License,
+   or (at your option) any later version.
+
+   LibGTop is distributed in the hope that it will be useful, but WITHOUT
+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+   for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with LibGTop; see the file COPYING. If not, write to the
+   Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.
+*/
+
+#include <config.h>
+#include <glibtop/procwd.h>
+#include <glibtop/error.h>
+
+#include <glibtop_private.h>
+
+#include <unistd.h>
+#include <dirent.h>
+#include <sys/types.h>
+
+
+void
+_glibtop_init_proc_wd_s(glibtop *server)
+{
+	server->sysdeps.proc_wd =
+	(1 << GLIBTOP_PROC_WD_EXE) +
+	(1 << GLIBTOP_PROC_WD_ROOT) +
+	(1 << GLIBTOP_PROC_WD_NUMBER);
+
+}
+
+static gboolean is_in(GPtrArray *array, const char *str)
+{
+	guint i;
+
+	for (i = 0; i != array->len; ++i) {
+		if (strcmp(g_ptr_array_index(array, i), str) == 0)
+			return TRUE;
+	}
+
+	return FALSE;
+}
+
+
+char**
+glibtop_get_proc_wd_s(glibtop *server, glibtop_proc_wd *buf, pid_t pid)
+{
+	GPtrArray *dirs;
+	char path[80];
+	char dir[256];
+	DIR *task;
+
+	memset(buf, 0, sizeof(glibtop_proc_wd));
+
+	g_snprintf(path, sizeof path, "/proc/%u/root", pid);
+	if (safe_readlink(path, buf->root, sizeof buf->root))
+		buf->flags |= (1 << GLIBTOP_PROC_WD_ROOT);
+
+	g_snprintf(path, sizeof path, "/proc/%u/exe", pid);
+	if (safe_readlink(path, buf->exe, sizeof buf->exe))
+		buf->flags |= (1 << GLIBTOP_PROC_WD_EXE);
+
+	dirs = g_ptr_array_sized_new(2);
+
+	g_snprintf(path, sizeof path, "/proc/%u/cwd", pid);
+	if (safe_readlink(path, dir, sizeof dir))
+		g_ptr_array_add(dirs, g_strdup(dir));
+
+	g_snprintf(path, sizeof path, "/proc/%u/task", pid);
+	if ((task = opendir(path)) != NULL) {
+		struct dirent *sub;
+		while ((sub = readdir(task)) != NULL) {
+			/* task dirs have numeric name */
+			if (!isdigit(sub->d_name[0]))
+				continue;
+			g_snprintf(path, sizeof path, "/proc/%u/task/%s/cwd", pid, sub->d_name);
+			if (safe_readlink(path, dir, sizeof dir) && !is_in(dirs, dir))
+				g_ptr_array_add(dirs, g_strdup(dir));
+		}
+		closedir(task);
+	}
+
+	buf->number = dirs->len;
+	buf->flags |= (1 << GLIBTOP_PROC_WD_NUMBER);
+
+	g_ptr_array_add(dirs, NULL);
+
+	return (char**) g_ptr_array_free(dirs, FALSE);
+}
+
--- origsrc/libgtop-2.24.4/sysdeps/cygwin/sem_limits.c	1969-12-31 18:00:00.000000000 -0600
+++ src/libgtop-2.24.4/sysdeps/cygwin/sem_limits.c	2009-02-16 01:36:49.593750000 -0600
@@ -0,0 +1,84 @@
+/* Copyright (C) 1998-99 Martin Baulig
+   This file is part of LibGTop 1.0.
+
+   Contributed by Martin Baulig <martin@home-of-linux.org>, April 1998.
+
+   LibGTop is free software; you can redistribute it and/or modify it
+   under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License,
+   or (at your option) any later version.
+
+   LibGTop is distributed in the hope that it will be useful, but WITHOUT
+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+   for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with LibGTop; see the file COPYING. If not, write to the
+   Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.
+*/
+
+#include <config.h>
+#include <glibtop/sem_limits.h>
+
+#define _KERNEL
+#include <sys/ipc.h>
+#include <sys/sem.h>
+
+#ifdef _SEM_SEMUN_UNDEFINED
+
+/* glibc 2.1 will no longer defines semun, instead it defines
+ * _SEM_SEMUN_UNDEFINED so users can define semun on their own.
+ * Thanks to Albert K T Hui <avatar@deva.net>. */
+
+union semun
+{
+	int val;
+	struct semid_ds *buf;
+	unsigned short int *array;
+	struct seminfo *__buf;
+};
+#endif
+
+static const unsigned long _glibtop_sysdeps_sem_limits =
+(1L << GLIBTOP_IPC_SEMMAP) + (1L << GLIBTOP_IPC_SEMMNI) +
+(1L << GLIBTOP_IPC_SEMMNS) + (1L << GLIBTOP_IPC_SEMMNU) +
+(1L << GLIBTOP_IPC_SEMMSL) + (1L << GLIBTOP_IPC_SEMOPM) +
+(1L << GLIBTOP_IPC_SEMUME) + (1L << GLIBTOP_IPC_SEMUSZ) +
+(1L << GLIBTOP_IPC_SEMVMX) + (1L << GLIBTOP_IPC_SEMAEM);
+
+/* Init function. */
+
+void
+_glibtop_init_sem_limits_s (glibtop *server)
+{
+	server->sysdeps.sem_limits = _glibtop_sysdeps_sem_limits;
+}
+
+/* Provides information about sysv ipc limits. */
+
+void
+glibtop_get_sem_limits_s (glibtop *server, glibtop_sem_limits *buf)
+{
+	struct seminfo	seminfo;
+	union semun	arg;
+
+	memset (buf, 0, sizeof (glibtop_sem_limits));
+
+	buf->flags = _glibtop_sysdeps_sem_limits;
+
+	arg.array = (void *) &seminfo;
+	semctl (0, 0, IPC_INFO, arg);
+
+	buf->semmap = seminfo.semmap;
+	buf->semmni = seminfo.semmni;
+	buf->semmns = seminfo.semmns;
+	buf->semmnu = seminfo.semmnu;
+	buf->semmsl = seminfo.semmsl;
+	buf->semopm = seminfo.semopm;
+	buf->semume = seminfo.semume;
+	buf->semusz = seminfo.semusz;
+	buf->semvmx = seminfo.semvmx;
+	buf->semaem = seminfo.semaem;
+}
--- origsrc/libgtop-2.24.4/sysdeps/cygwin/shm_limits.c	1969-12-31 18:00:00.000000000 -0600
+++ src/libgtop-2.24.4/sysdeps/cygwin/shm_limits.c	2009-02-16 01:33:46.093750000 -0600
@@ -0,0 +1,59 @@
+/* Copyright (C) 1998-99 Martin Baulig
+   This file is part of LibGTop 1.0.
+
+   Contributed by Martin Baulig <martin@home-of-linux.org>, April 1998.
+
+   LibGTop is free software; you can redistribute it and/or modify it
+   under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License,
+   or (at your option) any later version.
+
+   LibGTop is distributed in the hope that it will be useful, but WITHOUT
+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+   for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with LibGTop; see the file COPYING. If not, write to the
+   Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.
+*/
+
+#include <config.h>
+#include <glibtop/shm_limits.h>
+
+#define _KERNEL
+#include <sys/ipc.h>
+#include <sys/shm.h>
+
+static const unsigned long _glibtop_sysdeps_shm_limits =
+(1L << GLIBTOP_IPC_SHMMAX) + (1L << GLIBTOP_IPC_SHMMIN) +
+(1L << GLIBTOP_IPC_SHMMNI) + (1L << GLIBTOP_IPC_SHMSEG) +
+(1L << GLIBTOP_IPC_SHMALL);
+
+/* Init function. */
+
+void
+_glibtop_init_shm_limits_s (glibtop *server)
+{
+	server->sysdeps.shm_limits = _glibtop_sysdeps_shm_limits;
+}
+
+/* Provides information about sysv ipc limits. */
+
+void
+glibtop_get_shm_limits_s (glibtop *server, glibtop_shm_limits *buf)
+{
+	struct shminfo shminfo;
+
+	memset (buf, 0, sizeof (glibtop_shm_limits));
+
+	shmctl (0, IPC_INFO, (void *) &shminfo);
+
+	buf->shmmax = shminfo.shmmax;
+	buf->shmmin = shminfo.shmmin;
+	buf->shmmni = shminfo.shmmni;
+	buf->shmseg = shminfo.shmseg;
+	buf->shmall = shminfo.shmall;
+	buf->flags = _glibtop_sysdeps_shm_limits;
+}
--- origsrc/libgtop-2.24.4/sysdeps/cygwin/siglist.c	1969-12-31 18:00:00.000000000 -0600
+++ src/libgtop-2.24.4/sysdeps/cygwin/siglist.c	2009-02-16 00:35:37.000000000 -0600
@@ -0,0 +1,143 @@
+/* Copyright (C) 1998-99 Martin Baulig
+   This file is part of LibGTop 1.0.
+
+   Contributed by Martin Baulig <martin@home-of-linux.org>, April 1998.
+
+   LibGTop is free software; you can redistribute it and/or modify it
+   under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License,
+   or (at your option) any later version.
+
+   LibGTop is distributed in the hope that it will be useful, but WITHOUT
+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+   for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with LibGTop; see the file COPYING. If not, write to the
+   Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.
+*/
+
+
+#include <config.h>
+#include <glibtop/signal.h>
+
+#include <signal.h>
+
+
+#if 0 /* comment */
+perl -nle 'print "{$1,\t\"$1\",\t\"$2\"}," if m|^#define\s*(SIG[A-Z0-9]+).*?/\*\s*(.*?)\s*\*/|'
+	< /usr/include/bits/signum.h
+#endif
+
+
+const glibtop_signame glibtop_sys_siglist [] =
+{
+#ifdef SIGHUP
+	{SIGHUP,	"SIGHUP",       "Hangup (POSIX)."},
+#endif
+#ifdef SIGINT
+	{SIGINT,	"SIGINT",       "Interrupt (ANSI)."},
+#endif
+#ifdef SIGQUIT
+	{SIGQUIT,       "SIGQUIT",      "Quit (POSIX)."},
+#endif
+#ifdef SIGILL
+	{SIGILL,	"SIGILL",       "Illegal instruction (ANSI)."},
+#endif
+#ifdef SIGTRAP
+	{SIGTRAP,       "SIGTRAP",      "Trace trap (POSIX)."},
+#endif
+#ifdef SIGABRT
+	{SIGABRT,       "SIGABRT",      "Abort (ANSI)."},
+#endif
+#ifdef SIGIOT
+	{SIGIOT,	"SIGIOT",       "IOT trap (4.2 BSD)."},
+#endif
+#ifdef SIGBUS
+	{SIGBUS,	"SIGBUS",       "BUS error (4.2 BSD)."},
+#endif
+#ifdef SIGFPE
+	{SIGFPE,	"SIGFPE",       "Floating-point exception (ANSI)."},
+#endif
+#ifdef SIGKILL
+	{SIGKILL,       "SIGKILL",      "Kill, unblockable (POSIX)."},
+#endif
+#ifdef SIGUSR1
+	{SIGUSR1,	"SIGUSR1",      "User-defined signal 1 (POSIX)."},
+#endif
+#ifdef SIGSEGV
+	{SIGSEGV,	"SIGSEGV",      "Segmentation violation (ANSI)."},
+#endif
+#ifdef SIGUSR2
+	{SIGUSR2,	"SIGUSR2",      "User-defined signal 2 (POSIX)."},
+#endif
+#ifdef SIGPIPE
+	{SIGPIPE,       "SIGPIPE",      "Broken pipe (POSIX)."},
+#endif
+#ifdef SIGALRM
+	{SIGALRM,       "SIGALRM",      "Alarm clock (POSIX)."},
+#endif
+#ifdef SIGTERM
+	{SIGTERM,       "SIGTERM",      "Termination (ANSI)."},
+#endif
+#ifdef SIGSTKFLT
+	{SIGSTKFLT,     "SIGSTKFLT",    "Stack fault."},
+#endif
+#ifdef SIGCLD
+	{SIGCLD,	"SIGCLD",       "Same as SIGCHLD (System V)."},
+#endif
+#ifdef SIGCHLD
+	{SIGCHLD,       "SIGCHLD",      "Child status has changed (POSIX)."},
+#endif
+#ifdef SIGCONT
+	{SIGCONT,       "SIGCONT",      "Continue (POSIX)."},
+#endif
+#ifdef SIGSTOP
+	{SIGSTOP,       "SIGSTOP",      "Stop, unblockable (POSIX)."},
+#endif
+#ifdef SIGTSTP
+	{SIGTSTP,       "SIGTSTP",      "Keyboard stop (POSIX)."},
+#endif
+#ifdef SIGTTIN
+	{SIGTTIN,       "SIGTTIN",      "Background read from tty (POSIX)."},
+#endif
+#ifdef SIGTTOU
+	{SIGTTOU,       "SIGTTOU",      "Background write to tty (POSIX)."},
+#endif
+#ifdef SIGURG
+	{SIGURG,	"SIGURG",       "Urgent condition on socket (4.2 BSD)."},
+#endif
+#ifdef SIGXCPU
+	{SIGXCPU,       "SIGXCPU",      "CPU limit exceeded (4.2 BSD)."},
+#endif
+#ifdef SIGXFSZ
+	{SIGXFSZ,       "SIGXFSZ",      "File size limit exceeded (4.2 BSD)."},
+#endif
+#ifdef SIGVTALRM
+	{SIGVTALRM,     "SIGVTALRM",    "Virtual alarm clock (4.2 BSD)."},
+#endif
+#ifdef SIGPROF
+	{SIGPROF,       "SIGPROF",      "Profiling alarm clock (4.2 BSD)."},
+#endif
+#ifdef SIGWINCH
+	{SIGWINCH,      "SIGWINCH",     "Window size change (4.3 BSD, Sun)."},
+#endif
+#ifdef SIGPOLL
+	{SIGPOLL,       "SIGPOLL",      "Pollable event occurred (System V)."},
+#endif
+#ifdef SIGIO
+	{SIGIO,		"SIGIO",	"I/O now possible (4.2 BSD)."},
+#endif
+#ifdef SIGPWR
+	{SIGPWR,	"SIGPWR",       "Power failure restart (System V)."},
+#endif
+#ifdef SIGSYS
+	{SIGSYS,	"SIGSYS",       "Bad system call."},
+#endif
+#ifdef SIGUNUSED
+	{SIGUNUSED,	"SIGUNUSED",	""},
+#endif
+	{0,		NULL,		NULL}
+};
--- origsrc/libgtop-2.24.4/sysdeps/cygwin/swap.c	1969-12-31 18:00:00.000000000 -0600
+++ src/libgtop-2.24.4/sysdeps/cygwin/swap.c	2009-02-16 01:24:45.359375000 -0600
@@ -0,0 +1,81 @@
+/* Copyright (C) 1998-99 Martin Baulig
+   This file is part of LibGTop 1.0.
+
+   Contributed by Martin Baulig <martin@home-of-linux.org>, April 1998.
+
+   LibGTop is free software; you can redistribute it and/or modify it
+   under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License,
+   or (at your option) any later version.
+
+   LibGTop is distributed in the hope that it will be useful, but WITHOUT
+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+   for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with LibGTop; see the file COPYING. If not, write to the
+   Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.
+*/
+
+#include <config.h>
+#include <glibtop/error.h>
+#include <glibtop/swap.h>
+
+#include "glibtop_private.h"
+
+#include <fcntl.h>
+
+static const unsigned long _glibtop_sysdeps_swap =
+(1L << GLIBTOP_SWAP_TOTAL) + (1L << GLIBTOP_SWAP_USED) +
+(1L << GLIBTOP_SWAP_FREE);
+
+static const unsigned long _glibtop_sysdeps_swap_paging =
+(1L << GLIBTOP_SWAP_PAGEIN) + (1L << GLIBTOP_SWAP_PAGEOUT);
+
+/* Init function. */
+
+void
+_glibtop_init_swap_s (glibtop *server)
+{
+	server->sysdeps.swap = _glibtop_sysdeps_swap |
+		_glibtop_sysdeps_swap_paging;
+}
+
+/* Provides information about swap usage. */
+
+#define MEMINFO		"/proc/meminfo"
+#define PROC_STAT	"/proc/stat"
+
+void
+glibtop_get_swap_s (glibtop *server, glibtop_swap *buf)
+{
+	char buffer [BUFSIZ], *p;
+
+	memset (buf, 0, sizeof (glibtop_swap));
+
+	file_to_buffer(server, buffer, sizeof buffer, MEMINFO);
+
+	buf->total = get_scaled(buffer, "SwapTotal:");
+	buf->free = get_scaled(buffer, "SwapFree:");
+	buf->used = buf->total - buf->free;
+
+	buf->flags = _glibtop_sysdeps_swap;
+
+	{
+		file_to_buffer (server, buffer, sizeof buffer, PROC_STAT);
+
+		p = strstr (buffer, "\nswap");
+
+		if(p)
+		{
+			p = skip_token (p);
+
+			buf->pagein  = strtoull (p, &p, 0);
+			buf->pageout = strtoull (p, &p, 0);
+
+			buf->flags |= _glibtop_sysdeps_swap_paging;
+		}
+	}
+}
--- origsrc/libgtop-2.24.4/sysdeps/cygwin/sysinfo.c	1969-12-31 18:00:00.000000000 -0600
+++ src/libgtop-2.24.4/sysdeps/cygwin/sysinfo.c	2009-02-16 00:35:37.000000000 -0600
@@ -0,0 +1,99 @@
+/* Copyright (C) 1998-99 Martin Baulig
+   This file is part of LibGTop 1.0.
+
+   Contributed by Martin Baulig <martin@home-of-linux.org>, April 1998.
+
+   LibGTop is free software; you can redistribute it and/or modify it
+   under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License,
+   or (at your option) any later version.
+
+   LibGTop is distributed in the hope that it will be useful, but WITHOUT
+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+   for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with LibGTop; see the file COPYING. If not, write to the
+   Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.
+*/
+
+#include <config.h>
+#include <glibtop/error.h>
+#include <glibtop/cpu.h>
+#include <glibtop/sysinfo.h>
+
+#include "glibtop_private.h"
+
+#define FILENAME "/proc/cpuinfo"
+
+static const unsigned long _glibtop_sysdeps_sysinfo =
+(1L << GLIBTOP_SYSINFO_CPUINFO);
+
+static glibtop_sysinfo sysinfo = { .flags = 0 };
+
+static void
+init_sysinfo (glibtop *server)
+{
+	char buffer [16384];
+	gchar ** processors;
+
+	if(G_LIKELY(sysinfo.flags)) return;
+
+	file_to_buffer(server, buffer, sizeof buffer, FILENAME);
+
+	/* cpuinfo records are seperated by a blank line */
+	processors = g_strsplit(buffer, "\n\n", 0);
+
+	for(sysinfo.ncpu = 0;
+	    sysinfo.ncpu < GLIBTOP_NCPU && processors[sysinfo.ncpu] && *processors[sysinfo.ncpu];
+	    sysinfo.ncpu++) {
+
+		gchar **parts, **p;
+
+		glibtop_entry * const cpuinfo = &sysinfo.cpuinfo[sysinfo.ncpu];
+
+		cpuinfo->labels = g_ptr_array_new ();
+
+		cpuinfo->values = g_hash_table_new_full(g_str_hash, g_str_equal,
+							g_free, g_free);
+
+		cpuinfo->descriptions = g_hash_table_new_full(g_str_hash, g_str_equal,
+							g_free, g_free);
+
+		/* "<key>    : <value>" */
+		parts = g_strsplit_set(processors[sysinfo.ncpu], ":\n", 0);
+
+		for(p = parts; *p && *(p+1); p += 2) {
+
+			/* stole the allocated memory */
+			gchar * const key   = g_strstrip(   *p   );
+			gchar * const value = g_strstrip( *(p+1) );
+
+			g_ptr_array_add(cpuinfo->labels, key);
+			g_hash_table_insert(cpuinfo->values, key, value);
+		}
+
+
+		/* the last key has no value and has not been added */
+		if(*p) g_free(*p);
+
+		/* just g_free instead of g_strvfree because we stole
+		   the memory*/
+
+		g_free(parts);
+
+	}
+
+	g_strfreev(processors);
+
+	sysinfo.flags = _glibtop_sysdeps_sysinfo;
+}
+
+const glibtop_sysinfo *
+glibtop_get_sysinfo_s (glibtop *server)
+{
+	init_sysinfo (server);
+	return &sysinfo;
+}
--- origsrc/libgtop-2.24.4/sysdeps/cygwin/uptime.c	1969-12-31 18:00:00.000000000 -0600
+++ src/libgtop-2.24.4/sysdeps/cygwin/uptime.c	2009-02-16 00:35:37.015625000 -0600
@@ -0,0 +1,61 @@
+/* Copyright (C) 1998-99 Martin Baulig
+   This file is part of LibGTop 1.0.
+
+   Contributed by Martin Baulig <martin@home-of-linux.org>, April 1998.
+
+   LibGTop is free software; you can redistribute it and/or modify it
+   under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License,
+   or (at your option) any later version.
+
+   LibGTop is distributed in the hope that it will be useful, but WITHOUT
+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+   for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with LibGTop; see the file COPYING. If not, write to the
+   Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.
+*/
+
+#include <config.h>
+#include <glibtop/error.h>
+#include <glibtop/uptime.h>
+
+#include "glibtop_private.h"
+
+#include <time.h>
+
+static const unsigned long _glibtop_sysdeps_uptime =
+  (1UL << GLIBTOP_UPTIME_UPTIME) \
++ (1UL << GLIBTOP_UPTIME_IDLETIME) \
++ (1UL << GLIBTOP_UPTIME_BOOT_TIME);
+
+/* Init function. */
+
+void
+_glibtop_init_uptime_s (glibtop *server)
+{
+	server->sysdeps.uptime = _glibtop_sysdeps_uptime;
+}
+
+/* Provides uptime and idle time. */
+
+#define FILENAME	"/proc/uptime"
+
+void
+glibtop_get_uptime_s (glibtop *server, glibtop_uptime *buf)
+{
+	char buffer [BUFSIZ], *p;
+
+	memset (buf, 0, sizeof (glibtop_uptime));
+
+	file_to_buffer(server, buffer, sizeof buffer, FILENAME);
+
+	buf->uptime   = g_ascii_strtod (buffer, &p);
+	buf->idletime = g_ascii_strtod (p, &p);
+	buf->boot_time = get_boot_time(server);
+
+	buf->flags = _glibtop_sysdeps_uptime;
+}
